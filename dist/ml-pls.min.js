!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).mlPls={})}(this,(function(t){"use strict";const e=Object.prototype.toString;var r=function(t){return e.call(t).endsWith("Array]")};function s(t){if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],s=1;s<t.length;s++)t[s]>e&&(e=t[s]);return e}function o(t){if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],s=1;s<t.length;s++)t[s]<e&&(e=t[s]);return e}function n(t){var e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!r(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==n.output){if(!r(n.output))throw new TypeError("output option must be an array if specified");e=n.output}else e=new Array(t.length);var i=o(t),h=s(t);if(i===h)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var l=n.min,u=void 0===l?n.autoMinMax?i:0:l,a=n.max,c=void 0===a?n.autoMinMax?h:1:a;if(u>=c)throw new RangeError("min option must be smaller than max option");for(var m=(c-u)/(h-i),f=0;f<t.length;f++)e[f]=(t[f]-i)*m+u;return e}function i(t,e,r){let s=r?t.rows:t.rows-1;if(e<0||e>s)throw new RangeError("Row index out of range")}function h(t,e,r){let s=r?t.columns:t.columns-1;if(e<0||e>s)throw new RangeError("Column index out of range")}function l(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function u(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function a(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some(e=>e<0||e>=t.rows))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function c(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some(e=>e<0||e>=t.columns))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function m(t,e,r,s,o){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(g("startRow",e),g("endRow",r),g("startColumn",s),g("endColumn",o),e>r||s>o||e<0||e>=t.rows||r<0||r>=t.rows||s<0||s>=t.columns||o<0||o>=t.columns)throw new RangeError("Submatrix indices are out of range")}function f(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=[];for(let s=0;s<t;s++)r.push(e);return r}function g(t,e){if("number"!=typeof e)throw new TypeError("".concat(t," must be a number"))}function w(t){const e=String(t);if(e.length<=8)return e.padEnd(8," ");const r=t.toPrecision(6);if(r.length<=8)return r;const s=t.toExponential(6),o=s.indexOf("e"),n=s.substring(o);return s.substring(0,8-n.length)+n}class p{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let s=new y(t,e);for(let o=0;o<t;o++)for(let t=0;t<e;t++)s.set(o,t,r[o*e+t]);return s}static rowVector(t){let e=new y(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new y(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new y(t,e)}static ones(t,e){return new y(t,e).fill(1)}static rand(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{random:s=Math.random}=r;let o=new y(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)o.set(r,t,s());return o}static randInt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{min:s=0,max:o=1e3,random:n=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(s>=o)throw new RangeError("min must be smaller than max");let i=o-s,h=new y(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=s+Math.round(n()*i);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let s=Math.min(t,e),o=this.zeros(t,e);for(let t=0;t<s;t++)o.set(t,t,r);return o}static diag(t,e,r){let s=t.length;void 0===e&&(e=s),void 0===r&&(r=e);let o=Math.min(s,e,r),n=this.zeros(e,r);for(let e=0;e<o;e++)n.set(e,e,t[e]);return n}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new y(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.min(t.get(n,r),e.get(n,r)));return o}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new this(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.max(t.get(n,r),e.get(n,r)));return o}static checkMatrix(t){return p.isMatrix(t)?t:new y(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);t++}return s}isReducedEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(s=!1);t++}return s}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let s=e;for(let o=e;o<t.rows;o++)t.get(o,r)>t.get(s,r)&&(s=o);if(0===t.get(s,r))r++;else{t.swapRows(e,s);let o=t.get(e,r);for(let s=r;s<t.columns;s++)t.set(e,s,t.get(e,s)/o);for(let s=e+1;s<t.rows;s++){let o=t.get(s,r)/t.get(e,r);t.set(s,r,0);for(let n=r+1;n<t.columns;n++)t.set(s,n,t.get(s,n)-t.get(e,n)*o)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,s=r-1;for(;s>=0;)if(0===t.maxRow(s))s--;else{let o=0,n=!1;for(;o<r&&!1===n;)1===t.get(s,o)?n=!0:o++;for(let r=0;r<s;r++){let n=t.get(r,o);for(let i=o;i<e;i++){let e=t.get(r,i)-n*t.get(s,i);t.set(r,i,e)}}s--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new y(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)s.setSubMatrix(this,this.rows*t,this.columns*e);return s}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){i(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return y.rowVector(this.getRow(t))}setRow(t,e){i(this,t),e=l(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){i(this,t),i(this,e);for(let r=0;r<this.columns;r++){let s=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,s)}return this}getColumn(t){h(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return y.columnVector(this.getColumn(t))}setColumn(t,e){h(this,t),e=u(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){h(this,t),h(this,e);for(let r=0;r<this.rows;r++){let s=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,s)}return this}addRowVector(t){t=l(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=l(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=l(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=l(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=u(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=u(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=u(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=u(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){i(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){h(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}min(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}maxRow(t){i(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){i(this,t);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s),r[1]=s);return r}minRow(t){i(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){i(this,t);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s),r[1]=s);return r}maxColumn(t){h(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){h(this,t);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)>e&&(e=this.get(s,t),r[0]=s);return r}minColumn(t){h(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){h(this,t);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)<e&&(e=this.get(s,t),r[0]=s);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"frobenius",e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError("unknown norm type: ".concat(t))}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){p.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<e.length;s++)r+=e[s]*t[s];return r}mmul(t){t=y.checkMatrix(t);let e=this.rows,r=this.columns,s=t.columns,o=new y(e,s),n=new Float64Array(r);for(let i=0;i<s;i++){for(let e=0;e<r;e++)n[e]=t.get(e,i);for(let t=0;t<e;t++){let e=0;for(let s=0;s<r;s++)e+=this.get(t,s)*n[s];o.set(t,i,e)}}return o}strassen2x2(t){t=y.checkMatrix(t);let e=new y(2,2);const r=this.get(0,0),s=t.get(0,0),o=this.get(0,1),n=t.get(0,1),i=this.get(1,0),h=t.get(1,0),l=this.get(1,1),u=t.get(1,1),a=(r+l)*(s+u),c=(i+l)*s,m=r*(n-u),f=l*(h-s),g=(r+o)*u,w=a+f-g+(o-l)*(h+u),p=m+g,d=c+f,b=a-c+m+(i-r)*(s+n);return e.set(0,0,w),e.set(0,1,p),e.set(1,0,d),e.set(1,1,b),e}strassen3x3(t){t=y.checkMatrix(t);let e=new y(3,3);const r=this.get(0,0),s=this.get(0,1),o=this.get(0,2),n=this.get(1,0),i=this.get(1,1),h=this.get(1,2),l=this.get(2,0),u=this.get(2,1),a=this.get(2,2),c=t.get(0,0),m=t.get(0,1),f=t.get(0,2),g=t.get(1,0),w=t.get(1,1),p=t.get(1,2),d=t.get(2,0),b=t.get(2,1),M=t.get(2,2),v=(r-n)*(-m+w),x=(-r+n+i)*(c-m+w),C=(n+i)*(-c+m),S=r*c,R=(-r+l+u)*(c-f+p),E=(-r+l)*(f-p),V=(l+u)*(-c+f),T=(-o+u+a)*(w+d-b),A=(o-a)*(w-b),O=o*d,P=(u+a)*(-d+b),k=(-o+i+h)*(p+d-M),Y=(o-h)*(p-M),F=(i+h)*(-d+M),N=S+O+s*g,X=(r+s+o-n-i-u-a)*w+x+C+S+T+O+P,I=S+R+V+(r+s+o-i-h-l-u)*p+O+k+F,L=v+i*(-c+m+g-w-p-d+M)+x+S+O+k+Y,q=v+x+C+S+h*b,D=O+k+Y+F+n*f,j=S+R+E+u*(-c+f+g-w-p-d+b)+T+A+O,z=T+A+O+P+l*m,U=S+R+E+V+a*M;return e.set(0,0,N),e.set(0,1,X),e.set(0,2,I),e.set(1,0,L),e.set(1,1,q),e.set(1,2,D),e.set(2,0,j),e.set(2,1,z),e.set(2,2,U),e}mmulStrassen(t){t=y.checkMatrix(t);let e=this.clone(),r=e.rows,s=e.columns,o=t.rows,n=t.columns;function i(t,e,r){let s=t.rows,o=t.columns;if(s===e&&o===r)return t;{let s=p.zeros(e,r);return s=s.setSubMatrix(t,0,0),s}}s!==o&&console.warn("Multiplying ".concat(r," x ").concat(s," and ").concat(o," x ").concat(n," matrix: dimensions do not match."));let h=Math.max(r,o),l=Math.max(s,n);return e=i(e,h,l),function t(e,r,s,o){if(s<=512||o<=512)return e.mmul(r);s%2==1&&o%2==1?(e=i(e,s+1,o+1),r=i(r,s+1,o+1)):s%2==1?(e=i(e,s+1,o),r=i(r,s+1,o)):o%2==1&&(e=i(e,s,o+1),r=i(r,s,o+1));let n=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),l=e.subMatrix(0,n-1,0,h-1),u=r.subMatrix(0,n-1,0,h-1),a=e.subMatrix(0,n-1,h,e.columns-1),c=r.subMatrix(0,n-1,h,r.columns-1),m=e.subMatrix(n,e.rows-1,0,h-1),f=r.subMatrix(n,r.rows-1,0,h-1),g=e.subMatrix(n,e.rows-1,h,e.columns-1),w=r.subMatrix(n,r.rows-1,h,r.columns-1),d=t(p.add(l,g),p.add(u,w),n,h),y=t(p.add(m,g),u,n,h),b=t(l,p.sub(c,w),n,h),M=t(g,p.sub(f,u),n,h),v=t(p.add(l,a),w,n,h),x=t(p.sub(m,l),p.add(u,c),n,h),C=t(p.sub(a,g),p.add(f,w),n,h),S=p.add(d,M);S.sub(v),S.add(C);let R=p.add(b,v),E=p.add(y,M),V=p.sub(d,y);V.add(b),V.add(x);let T=p.zeros(2*S.rows,2*S.columns);return T=T.setSubMatrix(S,0,0),T=T.setSubMatrix(R,S.rows,0),T=T.setSubMatrix(E,0,S.columns),T=T.setSubMatrix(V,S.rows,S.columns),T.subMatrix(0,s-1,0,o-1)}(e,t=i(t,h,l),h,l)}scaleRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new y(this.rows,this.columns);for(let t=0;t<this.rows;t++){const o=this.getRow(t);n(o,{min:e,max:r,output:o}),s.setRow(t,o)}return s}scaleColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new y(this.rows,this.columns);for(let t=0;t<this.columns;t++){const o=this.getColumn(t);n(o,{min:e,max:r,output:o}),s.setColumn(t,o)}return s}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),s=this.get(e,this.columns-1-r);this.set(e,r,s),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),s=this.get(this.rows-1-r,e);this.set(r,e,s),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=y.checkMatrix(t);let e=this.rows,r=this.columns,s=t.rows,o=t.columns,n=new y(e*s,r*o);for(let i=0;i<e;i++)for(let e=0;e<r;e++)for(let r=0;r<s;r++)for(let h=0;h<o;h++)n.set(s*i+r,o*e+h,this.get(i,e)*t.get(r,h));return n}transpose(){let t=new y(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d;for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d;for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,s){m(this,t,e,r,s);let o=new y(e-t+1,s-r+1);for(let n=t;n<=e;n++)for(let e=r;e<=s;e++)o.set(n-t,e-r,this.get(n,e));return o}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new y(t.length,r-e+1);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.rows)throw new RangeError("Row index out of range: ".concat(t[o]));s.set(o,n-e,this.get(t[o],n))}return s}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new y(r-e+1,t.length);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.columns)throw new RangeError("Column index out of range: ".concat(t[o]));s.set(n-e,o,this.get(n,t[o]))}return s}setSubMatrix(t,e,r){m(this,e,e+(t=y.checkMatrix(t)).rows-1,r,r+t.columns-1);for(let s=0;s<t.rows;s++)for(let o=0;o<t.columns;o++)this.set(e+s,r+o,t.get(s,o));return this}selection(t,e){let r=function(t,e,r){return{row:a(t,e),column:c(t,r)}}(this,t,e),s=new y(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let o=0;o<r.column.length;o++){let n=r.column[o];s.set(t,o,this.get(e,n))}}return s}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new y(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=f(t.rows);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]+=t.get(r,s);return e}(this);case"column":return function(t){let e=f(t.columns);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]+=t.get(r,s);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e+=t.get(r,s);return e}(this);default:throw new Error("invalid option: ".concat(t))}}product(t){switch(t){case"row":return function(t){let e=f(t.rows,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]*=t.get(r,s);return e}(this);case"column":return function(t){let e=f(t.columns,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]*=t.get(r,s);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e*=t.get(r,s);return e}(this);default:throw new Error("invalid option: ".concat(t))}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error("invalid option: ".concat(t))}}variance(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<s;i++){let s=0,h=0,l=0;for(let e=0;e<o;e++)l=t.get(i,e)-r[i],s+=l,h+=l*l;e?n.push((h-s*s/o)/(o-1)):n.push((h-s*s/o)/o)}return n}(this,r,s);case"column":if(!Array.isArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<o;i++){let o=0,h=0,l=0;for(let e=0;e<s;e++)l=t.get(e,i)-r[i],o+=l,h+=l*l;e?n.push((h-o*o/s)/(s-1)):n.push((h-o*o/s)/s)}return n}(this,r,s);case void 0:if("number"!=typeof s)throw new TypeError("mean must be a number");return function(t,e,r){const s=t.rows,o=t.columns,n=s*o;let i=0,h=0,l=0;for(let e=0;e<s;e++)for(let s=0;s<o;s++)l=t.get(e,s)-r,i+=l,h+=l*l;return e?(h-i*i/n)/(n-1):(h-i*i/n)/n}(this,r,s);default:throw new Error("invalid option: ".concat(t))}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[r])}(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[s])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e)}(this,r),this;default:throw new Error("invalid option: ".concat(t))}}scale(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let s=0;for(let e=0;e<t.columns;e++)s+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(s))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let s=0;for(let e=0;e<t.rows;e++)s+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(s))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[s])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let s=0;s<t.columns;s++)for(let o=0;o<t.rows;o++)r+=Math.pow(t.get(o,s),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e)}(this,r),this;default:throw new Error("invalid option: ".concat(t))}}}function d(t,e){return t-e}p.prototype.klass="Matrix","undefined"!=typeof Symbol&&(p.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){const t=" ".repeat(2),e=" ".repeat(4);return"".concat(this.constructor.name," {\n").concat(t,"[\n").concat(e).concat(function(t,e){const{rows:r,columns:s}=t,o=Math.min(r,15),n=Math.min(s,10),i=[];for(let e=0;e<o;e++){let r=[];for(let s=0;s<n;s++)r.push(w(t.get(e,s)));i.push("".concat(r.join(" ")))}n!==s&&(i[i.length-1]+=" ... ".concat(s-10," more columns"));o!==r&&i.push("... ".concat(r-15," more rows"));return i.join("\n".concat(e))}(this,e),"\n").concat(t,"]\n").concat(t,"rows: ").concat(this.rows,"\n").concat(t,"columns: ").concat(this.columns,"\n}")}),p.random=p.rand,p.randomInt=p.randInt,p.diagonal=p.diag,p.prototype.diagonal=p.prototype.diag,p.identity=p.eye,p.prototype.negate=p.prototype.neg,p.prototype.tensorProduct=p.prototype.kroneckerProduct;class y extends p{constructor(t,e){if(super(),y.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>0){if(this.data=[],!(Number.isInteger(e)&&e>0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if(t=r.length,"number"!=typeof(e=r[0].length)||0===e)throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<t;s++){if(r[s].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[s]))}}}return this.rows=t,this.columns=e,this}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){if(i(this,t),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),i(this,t,!0),e=Float64Array.from(l(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){if(h(this,t),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let s=0;s<t;s++)r[s]=this.data[e][s];for(let s=t+1;s<this.columns;s++)r[s-1]=this.data[e][s];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),h(this,t,!0),e=u(this,e);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let o=0;for(;o<t;o++)s[o]=this.data[r][o];for(s[o++]=e[r];o<this.columns+1;o++)s[o]=this.data[r][o-1];this.data[r]=s}return this.columns+=1,this}}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}(p,y);class b extends p{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}class M{constructor(t){let e,r,s,o,n,i,h,l,u,a=(t=b.checkMatrix(t)).clone(),c=a.rows,m=a.columns,f=new Float64Array(c),g=1;for(e=0;e<c;e++)f[e]=e;for(l=new Float64Array(c),r=0;r<m;r++){for(e=0;e<c;e++)l[e]=a.get(e,r);for(e=0;e<c;e++){for(u=Math.min(e,r),n=0,s=0;s<u;s++)n+=a.get(e,s)*l[s];l[e]-=n,a.set(e,r,l[e])}for(o=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[o])&&(o=e);if(o!==r){for(s=0;s<m;s++)i=a.get(o,s),a.set(o,s,a.get(r,s)),a.set(r,s,i);h=f[o],f[o]=f[r],f[r]=h,g=-g}if(r<c&&0!==a.get(r,r))for(e=r+1;e<c;e++)a.set(e,r,a.get(e,r)/a.get(r,r))}this.LU=a,this.pivotVector=f,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=y.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,s,o,n=t.columns,i=t.subMatrixRow(this.pivotVector,0,n-1),h=e.columns;for(o=0;o<h;o++)for(r=o+1;r<h;r++)for(s=0;s<n;s++)i.set(r,s,i.get(r,s)-i.get(o,s)*e.get(r,o));for(o=h-1;o>=0;o--){for(s=0;s<n;s++)i.set(o,s,i.get(o,s)/e.get(o,o));for(r=0;r<o;r++)for(s=0;s<n;s++)i.set(r,s,i.get(r,s)-i.get(o,s)*e.get(r,o))}return i}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let s=0;s<r;s++)e*=t.get(s,s);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new y(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o>e?s.set(o,e,t.get(o,e)):o===e?s.set(o,e,1):s.set(o,e,0);return s}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new y(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o<=e?s.set(o,e,t.get(o,e)):s.set(o,e,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function v(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class x{constructor(t){let e,r,s,o,n=(t=b.checkMatrix(t)).clone(),i=t.rows,h=t.columns,l=new Float64Array(h);for(s=0;s<h;s++){let t=0;for(e=s;e<i;e++)t=v(t,n.get(e,s));if(0!==t){for(n.get(s,s)<0&&(t=-t),e=s;e<i;e++)n.set(e,s,n.get(e,s)/t);for(n.set(s,s,n.get(s,s)+1),r=s+1;r<h;r++){for(o=0,e=s;e<i;e++)o+=n.get(e,s)*n.get(e,r);for(o=-o/n.get(s,s),e=s;e<i;e++)n.set(e,r,n.get(e,r)+o*n.get(e,s))}}l[s]=-t}this.QR=n,this.Rdiag=l}solve(t){t=y.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s,o,n,i,h=t.columns,l=t.clone(),u=e.columns;for(n=0;n<u;n++)for(o=0;o<h;o++){for(i=0,s=n;s<r;s++)i+=e.get(s,n)*l.get(s,o);for(i=-i/e.get(n,n),s=n;s<r;s++)l.set(s,o,l.get(s,o)+i*e.get(s,n))}for(n=u-1;n>=0;n--){for(o=0;o<h;o++)l.set(n,o,l.get(n,o)/this.Rdiag[n]);for(s=0;s<n;s++)for(o=0;o<h;o++)l.set(s,o,l.get(s,o)-l.get(n,o)*e.get(s,n))}return l.subMatrix(0,u-1,0,h-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,s=r.columns,o=new y(s,s);for(t=0;t<s;t++)for(e=0;e<s;e++)t<e?o.set(t,e,r.get(t,e)):t===e?o.set(t,e,this.Rdiag[t]):o.set(t,e,0);return o}get orthogonalMatrix(){let t,e,r,s,o=this.QR,n=o.rows,i=o.columns,h=new y(n,i);for(r=i-1;r>=0;r--){for(t=0;t<n;t++)h.set(t,r,0);for(h.set(r,r,1),e=r;e<i;e++)if(0!==o.get(r,r)){for(s=0,t=r;t<n;t++)s+=o.get(t,r)*h.get(t,e);for(s=-s/o.get(r,r),t=r;t<n;t++)h.set(t,e,h.get(t,e)+s*o.get(t,r))}}return h}}class C{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=(t=b.checkMatrix(t)).rows,s=t.columns;const{computeLeftSingularVectors:o=!0,computeRightSingularVectors:n=!0,autoTranspose:i=!1}=e;let h,l=Boolean(o),u=Boolean(n),a=!1;if(r<s)if(i){h=t.transpose(),r=h.rows,s=h.columns,a=!0;let e=l;l=u,u=e}else h=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else h=t.clone();let c=Math.min(r,s),m=Math.min(r+1,s),f=new Float64Array(m),g=new y(r,c),w=new y(s,s),p=new Float64Array(s),d=new Float64Array(r),M=new Float64Array(m);for(let t=0;t<m;t++)M[t]=t;let x=Math.min(r-1,s),C=Math.max(0,Math.min(s-2,r)),S=Math.max(x,C);for(let t=0;t<S;t++){if(t<x){f[t]=0;for(let e=t;e<r;e++)f[t]=v(f[t],h.get(e,t));if(0!==f[t]){h.get(t,t)<0&&(f[t]=-f[t]);for(let e=t;e<r;e++)h.set(e,t,h.get(e,t)/f[t]);h.set(t,t,h.get(t,t)+1)}f[t]=-f[t]}for(let e=t+1;e<s;e++){if(t<x&&0!==f[t]){let s=0;for(let o=t;o<r;o++)s+=h.get(o,t)*h.get(o,e);s=-s/h.get(t,t);for(let o=t;o<r;o++)h.set(o,e,h.get(o,e)+s*h.get(o,t))}p[e]=h.get(t,e)}if(l&&t<x)for(let e=t;e<r;e++)g.set(e,t,h.get(e,t));if(t<C){p[t]=0;for(let e=t+1;e<s;e++)p[t]=v(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<s;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)d[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<s;r++)d[e]+=p[r]*h.get(e,r);for(let e=t+1;e<s;e++){let s=-p[e]/p[t+1];for(let o=t+1;o<r;o++)h.set(o,e,h.get(o,e)+s*d[o])}}if(u)for(let e=t+1;e<s;e++)w.set(e,t,p[e])}}let R=Math.min(s,r+1);if(x<s&&(f[x]=h.get(x,x)),r<R&&(f[R-1]=0),C+1<R&&(p[C]=h.get(C,R-1)),p[R-1]=0,l){for(let t=x;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=x-1;t>=0;t--)if(0!==f[t]){for(let e=t+1;e<c;e++){let s=0;for(let o=t;o<r;o++)s+=g.get(o,t)*g.get(o,e);s=-s/g.get(t,t);for(let o=t;o<r;o++)g.set(o,e,g.get(o,e)+s*g.get(o,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(u)for(let t=s-1;t>=0;t--){if(t<C&&0!==p[t])for(let e=t+1;e<s;e++){let r=0;for(let o=t+1;o<s;o++)r+=w.get(o,t)*w.get(o,e);r=-r/w.get(t+1,t);for(let o=t+1;o<s;o++)w.set(o,e,w.get(o,e)+r*w.get(o,t))}for(let e=0;e<s;e++)w.set(e,t,0);w.set(t,t,1)}let E=R-1,V=Number.EPSILON;for(;R>0;){let t,e;for(t=R-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+V*Math.abs(f[t]+Math.abs(f[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===R-2)e=4;else{let r;for(r=R-1;r>=t&&r!==t;r--){let e=(r!==R?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(f[r])<=V*e){f[r]=0;break}}r===t?e=3:r===R-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[R-2];p[R-2]=0;for(let r=R-2;r>=t;r--){let o=v(f[r],e),n=f[r]/o,i=e/o;if(f[r]=o,r!==t&&(e=-i*p[r-1],p[r-1]=n*p[r-1]),u)for(let t=0;t<s;t++)o=n*w.get(t,r)+i*w.get(t,R-1),w.set(t,R-1,-i*w.get(t,r)+n*w.get(t,R-1)),w.set(t,r,o)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let s=t;s<R;s++){let o=v(f[s],e),n=f[s]/o,i=e/o;if(f[s]=o,e=-i*p[s],p[s]=n*p[s],l)for(let e=0;e<r;e++)o=n*g.get(e,s)+i*g.get(e,t-1),g.set(e,t-1,-i*g.get(e,s)+n*g.get(e,t-1)),g.set(e,s,o)}break}case 3:{const e=Math.max(Math.abs(f[R-1]),Math.abs(f[R-2]),Math.abs(p[R-2]),Math.abs(f[t]),Math.abs(p[t])),o=f[R-1]/e,n=f[R-2]/e,i=p[R-2]/e,h=f[t]/e,a=p[t]/e,c=((n+o)*(n-o)+i*i)/2,m=o*i*(o*i);let d=0;0===c&&0===m||(d=c<0?0-Math.sqrt(c*c+m):Math.sqrt(c*c+m),d=m/(c+d));let y=(h+o)*(h-o)+d,b=h*a;for(let e=t;e<R-1;e++){let o=v(y,b);0===o&&(o=Number.MIN_VALUE);let n=y/o,i=b/o;if(e!==t&&(p[e-1]=o),y=n*f[e]+i*p[e],p[e]=n*p[e]-i*f[e],b=i*f[e+1],f[e+1]=n*f[e+1],u)for(let t=0;t<s;t++)o=n*w.get(t,e)+i*w.get(t,e+1),w.set(t,e+1,-i*w.get(t,e)+n*w.get(t,e+1)),w.set(t,e,o);if(o=v(y,b),0===o&&(o=Number.MIN_VALUE),n=y/o,i=b/o,f[e]=o,y=n*p[e]+i*f[e+1],f[e+1]=-i*p[e]+n*f[e+1],b=i*p[e+1],p[e+1]=n*p[e+1],l&&e<r-1)for(let t=0;t<r;t++)o=n*g.get(t,e)+i*g.get(t,e+1),g.set(t,e+1,-i*g.get(t,e)+n*g.get(t,e+1)),g.set(t,e,o)}p[R-2]=y;break}case 4:if(f[t]<=0&&(f[t]=f[t]<0?-f[t]:0,u))for(let e=0;e<=E;e++)w.set(e,t,-w.get(e,t));for(;t<E&&!(f[t]>=f[t+1]);){let e=f[t];if(f[t]=f[t+1],f[t+1]=e,u&&t<s-1)for(let r=0;r<s;r++)e=w.get(r,t+1),w.set(r,t+1,w.get(r,t)),w.set(r,t,e);if(l&&t<r-1)for(let s=0;s<r;s++)e=g.get(s,t+1),g.set(s,t+1,g.get(s,t)),g.set(s,t,e);t++}R--}}if(a){let t=w;w=g,g=t}this.m=r,this.n=s,this.s=f,this.U=g,this.V=w}solve(t){let e=t,r=this.threshold,s=this.s.length,o=y.zeros(s,s);for(let t=0;t<s;t++)Math.abs(this.s[t])<=r?o.set(t,t,0):o.set(t,t,1/this.s[t]);let n=this.U,i=this.rightSingularVectors,h=i.mmul(o),l=i.rows,u=n.rows,a=y.zeros(l,u);for(let t=0;t<l;t++)for(let e=0;e<u;e++){let r=0;for(let o=0;o<s;o++)r+=h.get(t,o)*n.get(e,o);a.set(t,e,r)}return a.mmul(e)}solveForDiagonal(t){return this.solve(y.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,s=t.columns,o=new y(r,this.s.length);for(let n=0;n<r;n++)for(let r=0;r<s;r++)Math.abs(this.s[r])>e&&o.set(n,r,t.get(n,r)/this.s[r]);let n=this.U,i=n.rows,h=n.columns,l=new y(r,i);for(let t=0;t<r;t++)for(let e=0;e<i;e++){let r=0;for(let s=0;s<h;s++)r+=o.get(t,s)*n.get(e,s);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let s=0,o=r.length;s<o;s++)r[s]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return y.diag(this.s)}}function S(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t=b.checkMatrix(t),e?new C(t).inverse():R(t,y.eye(t.rows))}function R(t,e){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=b.checkMatrix(t),e=b.checkMatrix(e),r?new C(t).solve(e):t.isSquare()?new M(t).solve(e):new x(t).solve(e)}class E{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t=b.checkMatrix(t);let{Y:r}=e;const{scaleScores:s=!1,maxIterations:o=1e3,terminationCriteria:n=1e-10}=e;let i;if(r){if(r=Array.isArray(r)&&"number"==typeof r[0]?y.columnVector(r):b.checkMatrix(r),!r.isColumnVector()||r.rows!==t.rows)throw new Error("Y must be a column vector of length X.rows");i=r}else i=t.getColumnVector(0);let h,l,u,a,c=1;for(let e=0;e<o&&c>n;e++)u=t.transpose().mmul(i).div(i.transpose().mmul(i).get(0,0)),u=u.div(u.norm()),h=t.mmul(u).div(u.transpose().mmul(u).get(0,0)),e>0&&(c=h.clone().sub(a).pow(2).sum()),a=h.clone(),r?(l=r.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),l=l.div(l.norm()),i=r.mmul(l).div(l.transpose().mmul(l).get(0,0))):i=h;if(r){let e=t.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0));e=e.div(e.norm());let s=t.clone().sub(h.clone().mmul(e.transpose())),o=i.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),n=r.clone().sub(h.clone().mulS(o.get(0,0)).mmul(l.transpose()));this.t=h,this.p=e.transpose(),this.w=u.transpose(),this.q=l,this.u=i,this.s=h.transpose().mmul(h),this.xResidual=s,this.yResidual=n,this.betas=o}else this.w=u.transpose(),this.s=h.transpose().mmul(h).sqrt(),this.t=s?h.clone().div(this.s.get(0,0)):h,this.xResidual=t.sub(h.mmul(u.transpose()))}}function V(t){return Math.sqrt(t.clone().apply(T).sum())}function T(t,e){this.set(t,e,this.get(t,e)**2)}function A(t,e){if(e)for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r){let s=t[e][r];t[e][r]=null!==s?new y(t[e][r]):void 0}else for(let e=0;e<t.length;++e)t[e]=new y(t[e]);return t}class O{constructor(t,e){if(!0===t)this.meanX=e.meanX,this.stdDevX=e.stdDevX,this.meanY=e.meanY,this.stdDevY=e.stdDevY,this.PBQ=y.checkMatrix(e.PBQ),this.R2X=e.R2X,this.scale=e.scale,this.scaleMethod=e.scaleMethod,this.tolerance=e.tolerance;else{let{tolerance:e=1e-5,scale:r=!0}=t;this.tolerance=e,this.scale=r,this.latentVectors=t.latentVectors}}train(t,e){if(t=y.checkMatrix(t),e=y.checkMatrix(e),t.length!==e.length)throw new RangeError("The number of X rows must be equal to the number of Y rows");this.meanX=t.mean("column"),this.stdDevX=t.standardDeviation("column",{mean:this.meanX,unbiased:!0}),this.meanY=e.mean("column"),this.stdDevY=e.standardDeviation("column",{mean:this.meanY,unbiased:!0}),this.scale&&(t=t.clone().subRowVector(this.meanX).divRowVector(this.stdDevX),e=e.clone().subRowVector(this.meanY).divRowVector(this.stdDevY)),void 0===this.latentVectors&&(this.latentVectors=Math.min(t.rows-1,t.columns));let r=t.rows,s=t.columns,o=e.rows,n=e.columns,i=t.clone().mul(t).sum(),h=e.clone().mul(e).sum(),l=this.tolerance,u=this.latentVectors,a=y.zeros(r,u),c=y.zeros(s,u),m=y.zeros(o,u),f=y.zeros(n,u),g=y.zeros(u,u),w=c.clone(),p=0;for(;V(e)>l&&p<u;){let s=t.transpose(),o=e.transpose(),n=P(t.clone().mul(t)),i=P(e.clone().mul(e)),h=t.getColumnVector(n),u=e.getColumnVector(i);for(var d=y.zeros(r,1);V(h.clone().sub(d))>l;){var b=s.mmul(u);b.div(V(b)),d=h,h=t.mmul(b);var M=o.mmul(h);M.div(V(M)),u=e.mmul(M)}d=h;let x=s.mmul(d),C=d.transpose().mmul(d).get(0,0);var v=x.div(C);let S=V(v);v.div(S),d.mul(S),b.mul(S),x=u.transpose().mmul(d),C=d.transpose().mmul(d).get(0,0);let R=x.div(C).get(0,0);t.sub(d.mmul(v.transpose())),e.sub(d.clone().mul(R).mmul(M.transpose())),a.setColumn(p,d),c.setColumn(p,v),m.setColumn(p,u),f.setColumn(p,M),w.setColumn(p,b),g.set(p,p,R),p++}p--,a=a.subMatrix(0,a.rows-1,0,p),c=c.subMatrix(0,c.rows-1,0,p),m=m.subMatrix(0,m.rows-1,0,p),f=f.subMatrix(0,f.rows-1,0,p),w=w.subMatrix(0,w.rows-1,0,p),g=g.subMatrix(0,p,0,p),this.ssqYcal=h,this.E=t,this.F=e,this.T=a,this.P=c,this.U=m,this.Q=f,this.W=w,this.B=g,this.PBQ=c.mmul(g).mmul(f.transpose()),this.R2X=d.transpose().mmul(d).mmul(v.transpose().mmul(v)).div(i).get(0,0)}predict(t){let e=y.checkMatrix(t);this.scale&&(e=e.subRowVector(this.meanX).divRowVector(this.stdDevX));let r=e.mmul(this.PBQ);return r=r.mulRowVector(this.stdDevY).addRowVector(this.meanY),r}getExplainedVariance(){return this.R2X}toJSON(){return{name:"PLS",R2X:this.R2X,meanX:this.meanX,stdDevX:this.stdDevX,meanY:this.meanY,stdDevY:this.stdDevY,PBQ:this.PBQ,tolerance:this.tolerance,scale:this.scale}}static load(t){if("PLS"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new O(!0,t)}}function P(t){return y.rowVector(t.sum("column")).maxIndex()[0]}class k{constructor(t,e){if(!0===t)this.trainingSet=new y(e.trainingSet),this.YLoadingMat=new y(e.YLoadingMat),this.SigmaPow=new y(e.SigmaPow),this.YScoreMat=new y(e.YScoreMat),this.predScoreMat=A(e.predScoreMat,!1),this.YOrthLoadingVec=A(e.YOrthLoadingVec,!1),this.YOrthEigen=e.YOrthEigen,this.YOrthScoreMat=A(e.YOrthScoreMat,!1),this.toNorm=A(e.toNorm,!1),this.TURegressionCoeff=A(e.TURegressionCoeff,!1),this.kernelX=A(e.kernelX,!0),this.kernel=e.kernel,this.orthogonalComp=e.orthogonalComp,this.predictiveComp=e.predictiveComp;else{if(void 0===t.predictiveComponents)throw new RangeError("no predictive components found!");if(void 0===t.orthogonalComponents)throw new RangeError("no orthogonal components found!");if(void 0===t.kernel)throw new RangeError("no kernel found!");this.orthogonalComp=t.orthogonalComponents,this.predictiveComp=t.predictiveComponents,this.kernel=t.kernel}}train(t,e){t=y.checkMatrix(t),e=y.checkMatrix(e),this.trainingSet=t.clone();let r=this.kernel.compute(t),s=y.eye(r.rows,r.rows,1),o=r;r=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)r[t]=new Array(this.orthogonalComp+1);r[0][0]=o;let n=new C(e.transpose().mmul(r[0][0]).mmul(e),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1}),i=n.leftSingularVectors,h=n.diagonalMatrix;i=i.subMatrix(0,i.rows-1,0,this.predictiveComp-1),h=h.subMatrix(0,this.predictiveComp-1,0,this.predictiveComp-1);let l=e.mmul(i),u=new Array(this.orthogonalComp+1),a=new Array(this.orthogonalComp+1),c=new Array(this.orthogonalComp),m=new Array(this.orthogonalComp),f=new Array(this.orthogonalComp),g=new Array(this.orthogonalComp),w=y.pow(h,-.5);w.apply((function(t,e){this.get(t,e)===1/0&&this.set(t,e,0)}));for(let t=0;t<this.orthogonalComp;++t){u[t]=r[0][t].transpose().mmul(l).mmul(w);let e=u[t].transpose();a[t]=S(e.mmul(u[t])).mmul(e).mmul(l),n=new C(e.mmul(y.sub(r[t][t],u[t].mmul(e))).mmul(u[t]),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1});let o=n.leftSingularVectors,i=n.diagonalMatrix;m[t]=o.subMatrix(0,o.rows-1,0,0),f[t]=i.get(0,0),c[t]=y.sub(r[t][t],u[t].mmul(e)).mmul(u[t]).mmul(m[t]).mul(Math.pow(f[t],-.5));let h=c[t].transpose();g[t]=y.sqrt(h.mmul(c[t])),c[t]=c[t].divRowVector(g[t]);let p=y.sub(s,c[t].mmul(c[t].transpose()));r[0][t+1]=r[0][t].mmul(p),r[t+1][t+1]=p.mmul(r[t][t]).mmul(p)}let p=u[this.orthogonalComp]=r[0][this.orthogonalComp].transpose().mmul(l).mmul(w),d=p.transpose();a[this.orthogonalComp]=S(d.mmul(p)).mmul(d).mmul(l),this.YLoadingMat=i,this.SigmaPow=w,this.YScoreMat=l,this.predScoreMat=u,this.YOrthLoadingVec=m,this.YOrthEigen=f,this.YOrthScoreMat=c,this.toNorm=g,this.TURegressionCoeff=a,this.kernelX=r}predict(t){let e=this.kernel.compute(t,this.trainingSet),r=e;e=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)e[t]=new Array(this.orthogonalComp+1);e[0][0]=r;let s,o=new Array(this.orthogonalComp),n=new Array(this.orthogonalComp);for(s=0;s<this.orthogonalComp;++s){n[s]=e[s][0].mmul(this.YScoreMat).mmul(this.SigmaPow),o[s]=y.sub(e[s][s],n[s].mmul(this.predScoreMat[s].transpose())).mmul(this.predScoreMat[s]).mmul(this.YOrthLoadingVec[s]).mul(Math.pow(this.YOrthEigen[s],-.5)),o[s]=o[s].divRowVector(this.toNorm[s]);let t=this.YOrthScoreMat[s].transpose();e[s+1][0]=y.sub(e[s][0],o[s].mmul(t).mmul(this.kernelX[0][s].transpose()));let r=y.sub(e[s][0],e[s][s].mmul(this.YOrthScoreMat[s]).mmul(t)),i=o[s].mmul(t).mmul(this.kernelX[s][s]),h=i.mmul(this.YOrthScoreMat[s]).mmul(t);e[s+1][s+1]=r.sub(i).add(h)}return n[s]=e[s][0].mmul(this.YScoreMat).mmul(this.SigmaPow),{prediction:n[s].mmul(this.TURegressionCoeff[s]).mmul(this.YLoadingMat.transpose()),predScoreMat:n,predYOrthVectors:o}}toJSON(){return{name:"K-OPLS",YLoadingMat:this.YLoadingMat,SigmaPow:this.SigmaPow,YScoreMat:this.YScoreMat,predScoreMat:this.predScoreMat,YOrthLoadingVec:this.YOrthLoadingVec,YOrthEigen:this.YOrthEigen,YOrthScoreMat:this.YOrthScoreMat,toNorm:this.toNorm,TURegressionCoeff:this.TURegressionCoeff,kernelX:this.kernelX,trainingSet:this.trainingSet,orthogonalComp:this.orthogonalComp,predictiveComp:this.predictiveComp}}static load(t,e){if("K-OPLS"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));if(!e)throw new RangeError("You must provide a kernel for the model!");return t.kernel=e,new k(!0,t)}}class Y{constructor(t,e){if(t.length!==t[0].length)throw new Error("Confusion matrix must be square");if(e.length!==t.length)throw new Error("Confusion matrix and labels should have the same length");this.labels=e,this.matrix=t}static fromLabels(t,e){let r,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e.length!==t.length)throw new Error("predicted and actual must have the same length");r=s.labels?new Set(s.labels):new Set([...t,...e]),r=Array.from(r),s.sort&&r.sort(s.sort);const o=Array.from({length:r.length});for(let t=0;t<o.length;t++)o[t]=new Array(o.length),o[t].fill(0);for(let s=0;s<e.length;s++){const n=r.indexOf(t[s]),i=r.indexOf(e[s]);n>=0&&i>=0&&o[n][i]++}return new Y(o,r)}getMatrix(){return this.matrix}getLabels(){return this.labels}getTotalCount(){let t=0;for(let e=0;e<this.matrix.length;e++)for(let r=0;r<this.matrix.length;r++)t+=this.matrix[e][r];return t}getTrueCount(){let t=0;for(let e=0;e<this.matrix.length;e++)t+=this.matrix[e][e];return t}getFalseCount(){return this.getTotalCount()-this.getTrueCount()}getTruePositiveCount(t){const e=this.getIndex(t);return this.matrix[e][e]}getTrueNegativeCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)for(let s=0;s<this.matrix.length;s++)t!==e&&s!==e&&(r+=this.matrix[t][s]);return r}getFalsePositiveCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(r+=this.matrix[t][e]);return r}getFalseNegativeCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(r+=this.matrix[e][t]);return r}getPositiveCount(t){return this.getTruePositiveCount(t)+this.getFalseNegativeCount(t)}getNegativeCount(t){return this.getTrueNegativeCount(t)+this.getFalsePositiveCount(t)}getIndex(t){const e=this.labels.indexOf(t);if(-1===e)throw new Error("The label does not exist");return e}getTruePositiveRate(t){return this.getTruePositiveCount(t)/this.getPositiveCount(t)}getTrueNegativeRate(t){return this.getTrueNegativeCount(t)/this.getNegativeCount(t)}getPositivePredictiveValue(t){const e=this.getTruePositiveCount(t);return e/(e+this.getFalsePositiveCount(t))}getNegativePredictiveValue(t){const e=this.getTrueNegativeCount(t);return e/(e+this.getFalseNegativeCount(t))}getFalseNegativeRate(t){return 1-this.getTruePositiveRate(t)}getFalsePositiveRate(t){return 1-this.getTrueNegativeRate(t)}getFalseDiscoveryRate(t){const e=this.getFalsePositiveCount(t);return e/(e+this.getTruePositiveCount(t))}getFalseOmissionRate(t){const e=this.getFalseNegativeCount(t);return e/(e+this.getTruePositiveCount(t))}getF1Score(t){const e=this.getTruePositiveCount(t);return 2*e/(2*e+this.getFalsePositiveCount(t)+this.getFalseNegativeCount(t))}getMatthewsCorrelationCoefficient(t){const e=this.getTruePositiveCount(t),r=this.getTrueNegativeCount(t),s=this.getFalsePositiveCount(t),o=this.getFalseNegativeCount(t);return(e*r-s*o)/Math.sqrt((e+s)*(e+o)*(r+s)*(r+o))}getInformedness(t){return this.getTruePositiveRate(t)+this.getTrueNegativeRate(t)-1}getMarkedness(t){return this.getPositivePredictiveValue(t)+this.getNegativePredictiveValue(t)-1}getConfusionTable(t){return[[this.getTruePositiveCount(t),this.getFalseNegativeCount(t)],[this.getFalsePositiveCount(t),this.getTrueNegativeCount(t)]]}getAccuracy(){let t=0,e=0;for(let r=0;r<this.matrix.length;r++)for(let s=0;s<this.matrix.length;s++)r===s?t+=this.matrix[r][s]:e+=this.matrix[r][s];return t/(t+e)}getCount(t,e){const r=this.getIndex(t),s=this.getIndex(e);return this.matrix[r][s]}get accuracy(){return this.getAccuracy()}get total(){return this.getTotalCount()}}let F={};function N(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{numberOSC:s=100}=r;let o,n,i,h,l=y.checkMatrix(t.clone()),u=y.checkMatrix(e.clone()),a=u.getColumnVector(0),c=1;for(let t=0;t<s&&c>1e-10;t++)i=a.transpose().mmul(l).div(a.transpose().mmul(a).get(0,0)),i=i.transpose().div(V(i)),o=l.mmul(i).div(i.transpose().mmul(i).get(0,0)),n=o.transpose().mmul(u).div(o.transpose().mmul(o).get(0,0)),h=u.mmul(n.transpose()),h=h.div(n.transpose().mmul(n).get(0,0)),t>0&&(c=h.clone().sub(a).pow(2).sum()/h.clone().pow(2).sum()),a=h.clone();let m=o.transpose().mmul(l).div(o.transpose().mmul(o).get(0,0)),f=m.clone().sub(i.transpose().mmul(m.transpose()).div(i.transpose().mmul(i).get(0,0)).mmul(i.transpose()));f.div(F.norm(f));let g=l.mmul(f.transpose()).div(f.mmul(f.transpose()).get(0,0)),w=g.transpose().mmul(l).div(g.transpose().mmul(g).get(0,0)),p=l.clone().sub(g.mmul(w));return{filteredX:p,weightsXOrtho:f,loadingsXOrtho:w,scoresXOrtho:g,weightsXPred:i,loadingsXpred:m,scoresXpred:o,loadingsY:n}}function X(t){return t.clone().mul(t.clone()).sum()}F.norm=function(t){return Math.sqrt(t.clone().apply(T).sum())};class I{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!0===t){const t=r;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.stdevs=t.stdevs,this.model=t.model,this.tCV=t.tCV,this.tOrthCV=t.tOrthCV,void(this.mode=t.mode)}let s=t.clone();const{nComp:o=3,center:n=!0,scale:i=!0,cvFolds:h=[]}=r;let l,u;if("number"==typeof e[0])this.mode="regression",l=y.from1DArray(e.length,1,e);else if("string"==typeof e[0])throw this.mode="discriminant_analysis",l=e,new Error("discriminant analysis is not yet supported");if("Matrix"!==s.constructor.name)throw new TypeError("features must be of class Matrix");this.center=n,this.center?this.means=s.mean("column"):this.stdevs=null,this.scale=i,this.scale?this.stdevs=s.standardDeviation("column"):this.means=null,u=h.length>0?h:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,r=t.length,s=new Array(r);for(let t=0;t<r;t++)s[t]=t;let o=Math.floor(r/e),n=[],i=[];for(;s.length;){let t=Math.floor(Math.random()*s.length);n.push(s[t]),s.splice(t,1),n.length===o&&(i.push(n),n=[])}n.length&&n.forEach(t=>i[e-1].push(t)),i=i.slice(0,e);let h=i.map((t,e)=>({testIndex:t,trainIndex:[].concat(...i.filter((t,r)=>r!==e))}));return h}(e,5);let a=[];this.model=[],this.tCV=[],this.tOrthCV=[];let c,m=[],f=[];for(c=0;c<o;c++){let t=new y(l.rows,1),e=new y(l.rows,1),o=new y(l.rows,1),h=[],g=0;for(let r of u){let u=this._getTrainTest(s,l,r),a=u.testFeatures,f=u.trainFeatures,w=u.trainLabels,p=f.mean("column"),d=f.standardDeviation("column");n&&(f.center("column"),w.center("column")),i&&(f.scale("column"),w.scale("column")),h[g]=N(0===c?f:m[c-1][g].filteredX,w),m[c]=h;let y=new E(h[g].filteredX,{Y:w});a.center("column",{center:p}),a.scale("column",{scale:d});let b,M=a;for(let t=0;t<c+1;t++)b=M.clone().mmul(m[t][g].weightsXOrtho.transpose()),M.sub(b.clone().mmul(m[t][g].loadingsXOrtho));let v=M.clone().mmul(y.w.transpose()),x=v.clone().mmul(y.betas);for(let s=0;s<r.testIndex.length;s++)t.setRow(r.testIndex[s],[x.get(s,0)]),e.setRow(r.testIndex[s],[v.get(s,0)]),o.setRow(r.testIndex[s],[b.get(s,0)]);g++}if(this.tCV.push(e),this.tOrthCV.push(o),"regression"===this.mode){let e=X(l.center("column").scale("column")),r=1-X(l.clone().sub(t))/e;a.push(r)}else if("discriminant_analysis"===this.mode)throw new Error("discriminant analysis is not yet supported");f=0===c?this._predictAll(s,l):this._predictAll(f.xRes,l,r={scale:!1,center:!1}),f.Q2y=a,this.model.push(f)}let g=this.tCV,w=this.tOrthCV,p=this.model[c-1],d=p.XOrth,b=s.center("column").scale("column"),M=l.center("column").scale("column"),v=b.clone().sub(d),x=new E(v,{Y:M}),C=v.clone().sub(x.t.clone().mmul(x.p)),S=this.model.map(t=>t.R2x),R=this.model.map(t=>t.R2y);this.output={Q2y:a,R2x:S,R2y:R,tPred:p.plsC.t,pPred:p.plsC.p,wPred:p.plsC.w,betasPred:p.plsC.betas,Qpc:p.plsC.q,tCV:g,tOrthCV:w,tOrth:p.tOrth,pOrth:p.pOrth,wOrth:p.wOrth,XOrth:d,Yres:p.plsC.yResidual,E:C}}getLogs(){return this.output}getScores(){return{scoresX:this.tCV.map(t=>t.to1DArray()),scoresY:this.tOrthCV.map(t=>t.to1DArray())}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("OPLS"!==t.name)throw new RangeError("invalid model: ".concat(t.name));return new I(!0,[],t)}toJSON(){return{name:"OPLS",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,model:this.model,tCV:this.tCV,tOrthCV:this.tOrthCV}}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{trueLabels:r=[],nc:s=1}=e,o=[];r.length>0&&(r=y.from1DArray(r.length,1,r),o=r.clone());let n=t.clone();this.center&&(n.center("column"),o.center("column")),this.scale&&(n.scale("column"),o.scale("column"));let i,h,l,u,a,c=n.clone();for(let t=0;t<s;t++)h=this.model[t].wOrth.transpose(),l=this.model[t].pOrth,i=c.clone().mmul(h),c.sub(i.clone().mmul(l)),a=c.clone().mmul(this.model[t].plsC.w.transpose()),u=a.clone().mmul(this.model[t].plsC.betas);if(!(o.rows>0))return{tPred:a,tOrth:i,yHat:u};if("regression"===this.mode){let t=X(o);return{tPred:a,tOrth:i,yHat:u,Q2y:1-X(o.clone().sub(u))/t}}if("discriminant_analysis"===this.mode){let t=[];return t=Y.fromLabels(r.to1DArray(),u.to1DArray()),{tPred:a,tOrth:i,yHat:u,confusionMatrix:t}}}_predictAll(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{center:s=!0,scale:o=!0}=r;s&&(t.center("column"),e.center("column")),o&&(t.scale("column"),e.scale("column"),this.tssy=X(e),this.tssx=X(t));let n=N(t,e),i=new E(n.filteredX,{Y:e}),h=n.filteredX.clone().mmul(i.w.transpose()),l=h.clone().mmul(i.betas);return{R2y:1-X(e.clone().sub(l))/this.tssy,R2x:X(i.t.clone().mmul(i.p.clone()))/this.tssx,xRes:n.filteredX,tOrth:n.scoresXOrtho,pOrth:n.loadingsXOrtho,wOrth:n.weightsXOrtho,tPred:h,totalPred:l,XOrth:n.scoresXOrtho.clone().mmul(n.loadingsXOrtho),oplsC:n,plsC:i}}_getTrainTest(t,e,r){let s=new y(r.testIndex.length,t.columns),o=new y(r.testIndex.length,1);r.testIndex.forEach((r,n)=>{s.setRow(n,t.getRow(r)),o.setRow(n,e.getRow(r))});let n=new y(r.trainIndex.length,t.columns),i=new y(r.trainIndex.length,1);return r.trainIndex.forEach((r,s)=>{n.setRow(s,t.getRow(r)),i.setRow(s,e.getRow(r))}),{trainFeatures:n,testFeatures:s,trainLabels:i,testLabels:o}}}t.KOPLS=k,t.OPLS=I,t.PLS=O,t.oplsNIPALS=N,t.summaryMetadata=function(t){let e=t.length,r=typeof t[0],s={};switch(r){case"string":s={},t.forEach(t=>s[t]=(s[t]||0)+1);break;case"number":t=t.map(t=>t.toString()),s={},t.forEach(t=>s[t]=(s[t]||0)+1)}let o=Object.keys(s),n=o.length,i=t.map(t=>o.indexOf(t)),h=y.from1DArray(e,1,i);return{groupIDs:o,nClass:n,classVector:t,classFactor:i,classMatrix:h}},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=ml-pls.min.js.map
