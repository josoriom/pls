{"version":3,"file":"ml-pls.min.js","sources":["../node_modules/is-any-array/src/index.js","../node_modules/ml-matrix/node_modules/ml-array-max/lib-es6/index.js","../node_modules/ml-matrix/node_modules/ml-array-min/lib-es6/index.js","../node_modules/ml-matrix/node_modules/ml-array-rescale/lib-es6/index.js","../node_modules/ml-matrix/src/util.js","../node_modules/ml-matrix/src/inspect.js","../node_modules/ml-matrix/src/matrix.js","../node_modules/ml-matrix/src/stat.js","../node_modules/ml-matrix/src/mathOperations.js","../node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js","../node_modules/ml-matrix/src/dc/lu.js","../node_modules/ml-matrix/src/dc/util.js","../node_modules/ml-matrix/src/dc/qr.js","../node_modules/ml-matrix/src/dc/svd.js","../node_modules/ml-matrix/src/decompositions.js","../node_modules/ml-matrix/src/dc/nipals.js","../src/utils.js","../src/pls.js","../src/kopls.js","../../../../.nvm/versions/node/v12.5.0/lib/node_modules/ml-confusion-matrix/src/index.js","../src/oplsNIPALS.js","../src/tss.js","../src/OPLS.js","../../cross-validation/src/getFolds.js"],"sourcesContent":["'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the maximum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction max(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var maxValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\nexport default max;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the minimum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction min(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var minValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nexport default min;\n","import max from 'ml-array-max';\nimport min from 'ml-array-min';\nimport isArray from 'is-any-array';\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\nexport default rescale;\n","/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nexport function checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nexport function checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nexport function checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nexport function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nexport function newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n","export function inspectMatrix() {\n  const indent = ' '.repeat(2);\n  const indentData = ' '.repeat(4);\n  return `${this.constructor.name} {\n${indent}[\n${indentData}${inspectData(this, indentData)}\n${indent}]\n${indent}rows: ${this.rows}\n${indent}columns: ${this.columns}\n}`;\n}\n\nconst maxRows = 15;\nconst maxColumns = 10;\nconst maxNumSize = 8;\n\nfunction inspectData(matrix, indent) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j)));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indent}`);\n}\n\nfunction formatNumber(num) {\n  const numStr = String(num);\n  if (numStr.length <= maxNumSize) {\n    return numStr.padEnd(maxNumSize, ' ');\n  }\n  const precise = num.toPrecision(maxNumSize - 2);\n  if (precise.length <= maxNumSize) {\n    return precise;\n  }\n  const exponential = num.toExponential(maxNumSize - 2);\n  const eIndex = exponential.indexOf('e');\n  const e = exponential.substring(eIndex);\n  return exponential.substring(0, maxNumSize - e.length) + e;\n}\n","import rescale from 'ml-array-rescale';\n\nimport {\n  checkRowVector,\n  checkRowIndex,\n  checkColumnIndex,\n  checkColumnVector,\n  checkRange,\n  checkIndices,\n} from './util';\nimport {\n  sumByRow,\n  sumByColumn,\n  sumAll,\n  productByRow,\n  productByColumn,\n  productAll,\n  varianceByRow,\n  varianceByColumn,\n  varianceAll,\n  centerByRow,\n  centerByColumn,\n  centerAll,\n  scaleByRow,\n  scaleByColumn,\n  scaleAll,\n  getScaleByRow,\n  getScaleByColumn,\n  getScaleAll,\n} from './stat';\nimport { inspectMatrix } from './inspect';\nimport { installMathOperations } from './mathOperations';\n\nexport class AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    checkRowIndex(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    checkRowIndex(this, index);\n    array = checkRowVector(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    checkRowIndex(this, row1);\n    checkRowIndex(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    checkColumnIndex(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    checkColumnIndex(this, index);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    checkColumnIndex(this, column1);\n    checkColumnIndex(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    checkRowIndex(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  maxIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  minIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    let result = 0;\n    if (type === 'max') {\n      return this.max();\n    } else if (type === 'frobenius') {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.columns; j++) {\n          result = result + this.get(i, j) * this.get(i, j);\n        }\n      }\n      return Math.sqrt(result);\n    } else {\n      throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      resultat = resultat.setSubMatrix(c11, 0, 0);\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      rescale(row, { min, max, output: row });\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      rescale(column, {\n        min: min,\n        max: max,\n        output: column,\n      });\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    let indices = checkIndices(this, rowIndices, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < indices.row.length; i++) {\n      let rowIndex = indices.row[i];\n      for (let j = 0; j < indices.column.length; j++) {\n        let columnIndex = indices.column[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        newMatrix.set(row, column, this.get(row, column));\n      }\n    }\n    return newMatrix;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return sumByRow(this);\n      case 'column':\n        return sumByColumn(this);\n      case undefined:\n        return sumAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return productByRow(this);\n      case 'column':\n        return productByColumn(this);\n      case undefined:\n        return productAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByRow(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByColumn(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return varianceAll(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByRow(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByColumn(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        centerAll(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = getScaleByRow(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByRow(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = getScaleByColumn(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByColumn(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = getScaleAll(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        scaleAll(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[\n    Symbol.for('nodejs.util.inspect.custom')\n  ] = inspectMatrix;\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nexport default class Matrix extends AbstractMatrix {\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      return nRows.clone();\n    } else if (Number.isInteger(nRows) && nRows > 0) {\n      // Create an empty matrix\n      this.data = [];\n      if (Number.isInteger(nColumns) && nColumns > 0) {\n        for (let i = 0; i < nRows; i++) {\n          this.data.push(new Float64Array(nColumns));\n        }\n      } else {\n        throw new TypeError('nColumns must be a positive integer');\n      }\n    } else if (Array.isArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = arrayData[0].length;\n      if (typeof nColumns !== 'number' || nColumns === 0) {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n    this.rows = nRows;\n    this.columns = nColumns;\n    return this;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    checkRowIndex(this, index);\n    if (this.rows === 1) {\n      throw new RangeError('A matrix cannot have less than one row');\n    }\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    checkRowIndex(this, index, true);\n    array = Float64Array.from(checkRowVector(this, array, true));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    checkColumnIndex(this, index);\n    if (this.columns === 1) {\n      throw new RangeError('A matrix cannot have less than one column');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    checkColumnIndex(this, index, true);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\ninstallMathOperations(AbstractMatrix, Matrix);\n","import { newArray } from './util';\n\nexport function sumByRow(matrix) {\n  let sum = newArray(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function sumByColumn(matrix) {\n  let sum = newArray(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nexport function productByRow(matrix) {\n  let sum = newArray(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function productByColumn(matrix) {\n  let sum = newArray(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nexport function varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nexport function varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nexport function varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nexport function centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nexport function centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nexport function centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nexport function getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nexport function scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nexport function getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nexport function scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nexport function getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nexport function scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n","export function installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), value));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\n      }\n    }\n    return this;\n  };\n}\n","import { AbstractMatrix } from '../matrix';\n\nexport default class WrapperMatrix2D extends AbstractMatrix {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.rows = data.length;\n    this.columns = data[0].length;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nexport default class LuDecomposition {\n  constructor(matrix) {\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\n\n    let lu = matrix.clone();\n    let rows = lu.rows;\n    let columns = lu.columns;\n    let pivotVector = new Float64Array(rows);\n    let pivotSign = 1;\n    let i, j, k, p, s, t, v;\n    let LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n      pivotVector[i] = i;\n    }\n\n    LUcolj = new Float64Array(rows);\n\n    for (j = 0; j < columns; j++) {\n      for (i = 0; i < rows; i++) {\n        LUcolj[i] = lu.get(i, j);\n      }\n\n      for (i = 0; i < rows; i++) {\n        kmax = Math.min(i, j);\n        s = 0;\n        for (k = 0; k < kmax; k++) {\n          s += lu.get(i, k) * LUcolj[k];\n        }\n        LUcolj[i] -= s;\n        lu.set(i, j, LUcolj[i]);\n      }\n\n      p = j;\n      for (i = j + 1; i < rows; i++) {\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n          p = i;\n        }\n      }\n\n      if (p !== j) {\n        for (k = 0; k < columns; k++) {\n          t = lu.get(p, k);\n          lu.set(p, k, lu.get(j, k));\n          lu.set(j, k, t);\n        }\n\n        v = pivotVector[p];\n        pivotVector[p] = pivotVector[j];\n        pivotVector[j] = v;\n\n        pivotSign = -pivotSign;\n      }\n\n      if (j < rows && lu.get(j, j) !== 0) {\n        for (i = j + 1; i < rows; i++) {\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\n        }\n      }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n  }\n\n  isSingular() {\n    let data = this.LU;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      if (data.get(j, j) === 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  solve(value) {\n    value = Matrix.checkMatrix(value);\n\n    let lu = this.LU;\n    let rows = lu.rows;\n\n    if (rows !== value.rows) {\n      throw new Error('Invalid matrix dimensions');\n    }\n    if (this.isSingular()) {\n      throw new Error('LU matrix is singular');\n    }\n\n    let count = value.columns;\n    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n    let columns = lu.columns;\n    let i, j, k;\n\n    for (k = 0; k < columns; k++) {\n      for (i = k + 1; i < columns; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    for (k = columns - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / lu.get(k, k));\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    return X;\n  }\n\n  get determinant() {\n    let data = this.LU;\n    if (!data.isSquare()) {\n      throw new Error('Matrix must be square');\n    }\n    let determinant = this.pivotSign;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      determinant *= data.get(j, j);\n    }\n    return determinant;\n  }\n\n  get lowerTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i > j) {\n          X.set(i, j, data.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, 1);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get upperTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i <= j) {\n          X.set(i, j, data.get(i, j));\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get pivotPermutationVector() {\n    return Array.from(this.pivotVector);\n  }\n}\n","export function hypotenuse(a, b) {\n  let r = 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    return Math.abs(a) * Math.sqrt(1 + r * r);\n  }\n  if (b !== 0) {\n    r = a / b;\n    return Math.abs(b) * Math.sqrt(1 + r * r);\n  }\n  return 0;\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nimport { hypotenuse } from './util';\n\nexport default class QrDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let qr = value.clone();\n    let m = value.rows;\n    let n = value.columns;\n    let rdiag = new Float64Array(n);\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      let nrm = 0;\n      for (i = k; i < m; i++) {\n        nrm = hypotenuse(nrm, qr.get(i, k));\n      }\n      if (nrm !== 0) {\n        if (qr.get(k, k) < 0) {\n          nrm = -nrm;\n        }\n        for (i = k; i < m; i++) {\n          qr.set(i, k, qr.get(i, k) / nrm);\n        }\n        qr.set(k, k, qr.get(k, k) + 1);\n        for (j = k + 1; j < n; j++) {\n          s = 0;\n          for (i = k; i < m; i++) {\n            s += qr.get(i, k) * qr.get(i, j);\n          }\n          s = -s / qr.get(k, k);\n          for (i = k; i < m; i++) {\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n      rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n  }\n\n  solve(value) {\n    value = Matrix.checkMatrix(value);\n\n    let qr = this.QR;\n    let m = qr.rows;\n\n    if (value.rows !== m) {\n      throw new Error('Matrix row dimensions must agree');\n    }\n    if (!this.isFullRank()) {\n      throw new Error('Matrix is rank deficient');\n    }\n\n    let count = value.columns;\n    let X = value.clone();\n    let n = qr.columns;\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      for (j = 0; j < count; j++) {\n        s = 0;\n        for (i = k; i < m; i++) {\n          s += qr.get(i, k) * X.get(i, j);\n        }\n        s = -s / qr.get(k, k);\n        for (i = k; i < m; i++) {\n          X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n        }\n      }\n    }\n    for (k = n - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / this.Rdiag[k]);\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));\n        }\n      }\n    }\n\n    return X.subMatrix(0, n - 1, 0, count - 1);\n  }\n\n  isFullRank() {\n    let columns = this.QR.columns;\n    for (let i = 0; i < columns; i++) {\n      if (this.Rdiag[i] === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  get upperTriangularMatrix() {\n    let qr = this.QR;\n    let n = qr.columns;\n    let X = new Matrix(n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if (i < j) {\n          X.set(i, j, qr.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, this.Rdiag[i]);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get orthogonalMatrix() {\n    let qr = this.QR;\n    let rows = qr.rows;\n    let columns = qr.columns;\n    let X = new Matrix(rows, columns);\n    let i, j, k, s;\n\n    for (k = columns - 1; k >= 0; k--) {\n      for (i = 0; i < rows; i++) {\n        X.set(i, k, 0);\n      }\n      X.set(k, k, 1);\n      for (j = k; j < columns; j++) {\n        if (qr.get(k, k) !== 0) {\n          s = 0;\n          for (i = k; i < rows; i++) {\n            s += qr.get(i, k) * X.get(i, j);\n          }\n\n          s = -s / qr.get(k, k);\n\n          for (i = k; i < rows; i++) {\n            X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n    }\n    return X;\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nimport { hypotenuse } from './util';\n\nexport default class SingularValueDecomposition {\n  constructor(value, options = {}) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let m = value.rows;\n    let n = value.columns;\n\n    const {\n      computeLeftSingularVectors = true,\n      computeRightSingularVectors = true,\n      autoTranspose = false,\n    } = options;\n\n    let wantu = Boolean(computeLeftSingularVectors);\n    let wantv = Boolean(computeRightSingularVectors);\n\n    let swapped = false;\n    let a;\n    if (m < n) {\n      if (!autoTranspose) {\n        a = value.clone();\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',\n        );\n      } else {\n        a = value.transpose();\n        m = a.rows;\n        n = a.columns;\n        swapped = true;\n        let aux = wantu;\n        wantu = wantv;\n        wantv = aux;\n      }\n    } else {\n      a = value.clone();\n    }\n\n    let nu = Math.min(m, n);\n    let ni = Math.min(m + 1, n);\n    let s = new Float64Array(ni);\n    let U = new Matrix(m, nu);\n    let V = new Matrix(n, n);\n\n    let e = new Float64Array(n);\n    let work = new Float64Array(m);\n\n    let si = new Float64Array(ni);\n    for (let i = 0; i < ni; i++) si[i] = i;\n\n    let nct = Math.min(m - 1, n);\n    let nrt = Math.max(0, Math.min(n - 2, m));\n    let mrc = Math.max(nct, nrt);\n\n    for (let k = 0; k < mrc; k++) {\n      if (k < nct) {\n        s[k] = 0;\n        for (let i = k; i < m; i++) {\n          s[k] = hypotenuse(s[k], a.get(i, k));\n        }\n        if (s[k] !== 0) {\n          if (a.get(k, k) < 0) {\n            s[k] = -s[k];\n          }\n          for (let i = k; i < m; i++) {\n            a.set(i, k, a.get(i, k) / s[k]);\n          }\n          a.set(k, k, a.get(k, k) + 1);\n        }\n        s[k] = -s[k];\n      }\n\n      for (let j = k + 1; j < n; j++) {\n        if (k < nct && s[k] !== 0) {\n          let t = 0;\n          for (let i = k; i < m; i++) {\n            t += a.get(i, k) * a.get(i, j);\n          }\n          t = -t / a.get(k, k);\n          for (let i = k; i < m; i++) {\n            a.set(i, j, a.get(i, j) + t * a.get(i, k));\n          }\n        }\n        e[j] = a.get(k, j);\n      }\n\n      if (wantu && k < nct) {\n        for (let i = k; i < m; i++) {\n          U.set(i, k, a.get(i, k));\n        }\n      }\n\n      if (k < nrt) {\n        e[k] = 0;\n        for (let i = k + 1; i < n; i++) {\n          e[k] = hypotenuse(e[k], e[i]);\n        }\n        if (e[k] !== 0) {\n          if (e[k + 1] < 0) {\n            e[k] = 0 - e[k];\n          }\n          for (let i = k + 1; i < n; i++) {\n            e[i] /= e[k];\n          }\n          e[k + 1] += 1;\n        }\n        e[k] = -e[k];\n        if (k + 1 < m && e[k] !== 0) {\n          for (let i = k + 1; i < m; i++) {\n            work[i] = 0;\n          }\n          for (let i = k + 1; i < m; i++) {\n            for (let j = k + 1; j < n; j++) {\n              work[i] += e[j] * a.get(i, j);\n            }\n          }\n          for (let j = k + 1; j < n; j++) {\n            let t = -e[j] / e[k + 1];\n            for (let i = k + 1; i < m; i++) {\n              a.set(i, j, a.get(i, j) + t * work[i]);\n            }\n          }\n        }\n        if (wantv) {\n          for (let i = k + 1; i < n; i++) {\n            V.set(i, k, e[i]);\n          }\n        }\n      }\n    }\n\n    let p = Math.min(n, m + 1);\n    if (nct < n) {\n      s[nct] = a.get(nct, nct);\n    }\n    if (m < p) {\n      s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n      e[nrt] = a.get(nrt, p - 1);\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n      for (let j = nct; j < nu; j++) {\n        for (let i = 0; i < m; i++) {\n          U.set(i, j, 0);\n        }\n        U.set(j, j, 1);\n      }\n      for (let k = nct - 1; k >= 0; k--) {\n        if (s[k] !== 0) {\n          for (let j = k + 1; j < nu; j++) {\n            let t = 0;\n            for (let i = k; i < m; i++) {\n              t += U.get(i, k) * U.get(i, j);\n            }\n            t = -t / U.get(k, k);\n            for (let i = k; i < m; i++) {\n              U.set(i, j, U.get(i, j) + t * U.get(i, k));\n            }\n          }\n          for (let i = k; i < m; i++) {\n            U.set(i, k, -U.get(i, k));\n          }\n          U.set(k, k, 1 + U.get(k, k));\n          for (let i = 0; i < k - 1; i++) {\n            U.set(i, k, 0);\n          }\n        } else {\n          for (let i = 0; i < m; i++) {\n            U.set(i, k, 0);\n          }\n          U.set(k, k, 1);\n        }\n      }\n    }\n\n    if (wantv) {\n      for (let k = n - 1; k >= 0; k--) {\n        if (k < nrt && e[k] !== 0) {\n          for (let j = k + 1; j < n; j++) {\n            let t = 0;\n            for (let i = k + 1; i < n; i++) {\n              t += V.get(i, k) * V.get(i, j);\n            }\n            t = -t / V.get(k + 1, k);\n            for (let i = k + 1; i < n; i++) {\n              V.set(i, j, V.get(i, j) + t * V.get(i, k));\n            }\n          }\n        }\n        for (let i = 0; i < n; i++) {\n          V.set(i, k, 0);\n        }\n        V.set(k, k, 1);\n      }\n    }\n\n    let pp = p - 1;\n    let iter = 0;\n    let eps = Number.EPSILON;\n    while (p > 0) {\n      let k, kase;\n      for (k = p - 2; k >= -1; k--) {\n        if (k === -1) {\n          break;\n        }\n        const alpha =\n          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\n          e[k] = 0;\n          break;\n        }\n      }\n      if (k === p - 2) {\n        kase = 4;\n      } else {\n        let ks;\n        for (ks = p - 1; ks >= k; ks--) {\n          if (ks === k) {\n            break;\n          }\n          let t =\n            (ks !== p ? Math.abs(e[ks]) : 0) +\n            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n          if (Math.abs(s[ks]) <= eps * t) {\n            s[ks] = 0;\n            break;\n          }\n        }\n        if (ks === k) {\n          kase = 3;\n        } else if (ks === p - 1) {\n          kase = 1;\n        } else {\n          kase = 2;\n          k = ks;\n        }\n      }\n\n      k++;\n\n      switch (kase) {\n        case 1: {\n          let f = e[p - 2];\n          e[p - 2] = 0;\n          for (let j = p - 2; j >= k; j--) {\n            let t = hypotenuse(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            if (j !== k) {\n              f = -sn * e[j - 1];\n              e[j - 1] = cs * e[j - 1];\n            }\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, p - 1);\n                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));\n                V.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 2: {\n          let f = e[k - 1];\n          e[k - 1] = 0;\n          for (let j = k; j < p; j++) {\n            let t = hypotenuse(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            f = -sn * e[j];\n            e[j] = cs * e[j];\n            if (wantu) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, k - 1);\n                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 3: {\n          const scale = Math.max(\n            Math.abs(s[p - 1]),\n            Math.abs(s[p - 2]),\n            Math.abs(e[p - 2]),\n            Math.abs(s[k]),\n            Math.abs(e[k]),\n          );\n          const sp = s[p - 1] / scale;\n          const spm1 = s[p - 2] / scale;\n          const epm1 = e[p - 2] / scale;\n          const sk = s[k] / scale;\n          const ek = e[k] / scale;\n          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n          const c = sp * epm1 * (sp * epm1);\n          let shift = 0;\n          if (b !== 0 || c !== 0) {\n            if (b < 0) {\n              shift = 0 - Math.sqrt(b * b + c);\n            } else {\n              shift = Math.sqrt(b * b + c);\n            }\n            shift = c / (b + shift);\n          }\n          let f = (sk + sp) * (sk - sp) + shift;\n          let g = sk * ek;\n          for (let j = k; j < p - 1; j++) {\n            let t = hypotenuse(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            let cs = f / t;\n            let sn = g / t;\n            if (j !== k) {\n              e[j - 1] = t;\n            }\n            f = cs * s[j] + sn * e[j];\n            e[j] = cs * e[j] - sn * s[j];\n            g = sn * s[j + 1];\n            s[j + 1] = cs * s[j + 1];\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, j + 1);\n                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));\n                V.set(i, j, t);\n              }\n            }\n            t = hypotenuse(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            cs = f / t;\n            sn = g / t;\n            s[j] = t;\n            f = cs * e[j] + sn * s[j + 1];\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\n            g = sn * e[j + 1];\n            e[j + 1] = cs * e[j + 1];\n            if (wantu && j < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, j + 1);\n                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          e[p - 2] = f;\n          iter = iter + 1;\n          break;\n        }\n        case 4: {\n          if (s[k] <= 0) {\n            s[k] = s[k] < 0 ? -s[k] : 0;\n            if (wantv) {\n              for (let i = 0; i <= pp; i++) {\n                V.set(i, k, -V.get(i, k));\n              }\n            }\n          }\n          while (k < pp) {\n            if (s[k] >= s[k + 1]) {\n              break;\n            }\n            let t = s[k];\n            s[k] = s[k + 1];\n            s[k + 1] = t;\n            if (wantv && k < n - 1) {\n              for (let i = 0; i < n; i++) {\n                t = V.get(i, k + 1);\n                V.set(i, k + 1, V.get(i, k));\n                V.set(i, k, t);\n              }\n            }\n            if (wantu && k < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = U.get(i, k + 1);\n                U.set(i, k + 1, U.get(i, k));\n                U.set(i, k, t);\n              }\n            }\n            k++;\n          }\n          iter = 0;\n          p--;\n          break;\n        }\n        // no default\n      }\n    }\n\n    if (swapped) {\n      let tmp = V;\n      V = U;\n      U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n  }\n\n  solve(value) {\n    let Y = value;\n    let e = this.threshold;\n    let scols = this.s.length;\n    let Ls = Matrix.zeros(scols, scols);\n\n    for (let i = 0; i < scols; i++) {\n      if (Math.abs(this.s[i]) <= e) {\n        Ls.set(i, i, 0);\n      } else {\n        Ls.set(i, i, 1 / this.s[i]);\n      }\n    }\n\n    let U = this.U;\n    let V = this.rightSingularVectors;\n\n    let VL = V.mmul(Ls);\n    let vrows = V.rows;\n    let urows = U.rows;\n    let VLU = Matrix.zeros(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < scols; k++) {\n          sum += VL.get(i, k) * U.get(j, k);\n        }\n        VLU.set(i, j, sum);\n      }\n    }\n\n    return VLU.mmul(Y);\n  }\n\n  solveForDiagonal(value) {\n    return this.solve(Matrix.diag(value));\n  }\n\n  inverse() {\n    let V = this.V;\n    let e = this.threshold;\n    let vrows = V.rows;\n    let vcols = V.columns;\n    let X = new Matrix(vrows, this.s.length);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < vcols; j++) {\n        if (Math.abs(this.s[j]) > e) {\n          X.set(i, j, V.get(i, j) / this.s[j]);\n        }\n      }\n    }\n\n    let U = this.U;\n\n    let urows = U.rows;\n    let ucols = U.columns;\n    let Y = new Matrix(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < ucols; k++) {\n          sum += X.get(i, k) * U.get(j, k);\n        }\n        Y.set(i, j, sum);\n      }\n    }\n\n    return Y;\n  }\n\n  get condition() {\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n  }\n\n  get norm2() {\n    return this.s[0];\n  }\n\n  get rank() {\n    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\n    let r = 0;\n    let s = this.s;\n    for (let i = 0, ii = s.length; i < ii; i++) {\n      if (s[i] > tol) {\n        r++;\n      }\n    }\n    return r;\n  }\n\n  get diagonal() {\n    return Array.from(this.s);\n  }\n\n  get threshold() {\n    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];\n  }\n\n  get leftSingularVectors() {\n    return this.U;\n  }\n\n  get rightSingularVectors() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    return Matrix.diag(this.s);\n  }\n}\n","import LuDecomposition from './dc/lu';\nimport QrDecomposition from './dc/qr';\nimport SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\nimport WrapperMatrix2D from './wrap/WrapperMatrix2D';\n\nexport function inverse(matrix, useSVD = false) {\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\n  if (useSVD) {\n    return new SingularValueDecomposition(matrix).inverse();\n  } else {\n    return solve(matrix, Matrix.eye(matrix.rows));\n  }\n}\n\nexport function solve(leftHandSide, rightHandSide, useSVD = false) {\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\n  if (useSVD) {\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\n  } else {\n    return leftHandSide.isSquare()\n      ? new LuDecomposition(leftHandSide).solve(rightHandSide)\n      : new QrDecomposition(leftHandSide).solve(rightHandSide);\n  }\n}\n","import WrapperMatrix2D from '../wrap/WrapperMatrix2D';\nimport Matrix from '../matrix';\n\nexport default class nipals {\n  constructor(X, options = {}) {\n    X = WrapperMatrix2D.checkMatrix(X);\n    let { Y } = options;\n    const {\n      scaleScores = false,\n      maxIterations = 1000,\n      terminationCriteria = 1e-10,\n    } = options;\n\n    let u;\n    if (Y) {\n      if (Array.isArray(Y) && typeof Y[0] === 'number') {\n        Y = Matrix.columnVector(Y);\n      } else {\n        Y = WrapperMatrix2D.checkMatrix(Y);\n      }\n      if (!Y.isColumnVector() || Y.rows !== X.rows) {\n        throw new Error('Y must be a column vector of length X.rows');\n      }\n      u = Y;\n    } else {\n      u = X.getColumnVector(0);\n    }\n\n    let diff = 1;\n    let t, q, w, tOld;\n\n    for (\n      let counter = 0;\n      counter < maxIterations && diff > terminationCriteria;\n      counter++\n    ) {\n      w = X.transpose()\n        .mmul(u)\n        .div(\n          u\n            .transpose()\n            .mmul(u)\n            .get(0, 0),\n        );\n      w = w.div(w.norm());\n\n      t = X.mmul(w).div(\n        w\n          .transpose()\n          .mmul(w)\n          .get(0, 0),\n      );\n\n      if (counter > 0) {\n        diff = t\n          .clone()\n          .sub(tOld)\n          .pow(2)\n          .sum();\n      }\n      tOld = t.clone();\n\n      if (Y) {\n        q = Y.transpose()\n          .mmul(t)\n          .div(\n            t\n              .transpose()\n              .mmul(t)\n              .get(0, 0),\n          );\n        q = q.div(q.norm());\n\n        u = Y.mmul(q).div(\n          q\n            .transpose()\n            .mmul(q)\n            .get(0, 0),\n        );\n      } else {\n        u = t;\n      }\n    }\n\n    if (Y) {\n      let p = X.transpose()\n        .mmul(t)\n        .div(\n          t\n            .transpose()\n            .mmul(t)\n            .get(0, 0),\n        );\n      p = p.div(p.norm());\n      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));\n      let residual = u\n        .transpose()\n        .mmul(t)\n        .div(\n          t\n            .transpose()\n            .mmul(t)\n            .get(0, 0),\n        );\n      let yResidual = Y.clone().sub(\n        t\n          .clone()\n          .mulS(residual.get(0, 0))\n          .mmul(q.transpose()),\n      );\n\n      this.t = t;\n      this.p = p.transpose();\n      this.w = w.transpose();\n      this.q = q;\n      this.u = u;\n      this.s = t.transpose().mmul(t);\n      this.xResidual = xResidual;\n      this.yResidual = yResidual;\n      this.betas = residual;\n    } else {\n      this.w = w.transpose();\n      this.s = t\n        .transpose()\n        .mmul(t)\n        .sqrt();\n      if (scaleScores) {\n        this.t = t.clone().div(this.s.get(0, 0));\n      } else {\n        this.t = t;\n      }\n      this.xResidual = X.sub(t.mmul(w.transpose()));\n    }\n  }\n}\n","import Matrix from 'ml-matrix';\nimport mean from 'ml-array-mean';\n\n/**\n * @private\n * Function that given vector, returns its norm\n * @param {Vector} X\n * @return {number} Norm of the vector\n */\nexport function norm(X) {\n  return Math.sqrt(\n    X.clone()\n      .apply(pow2array)\n      .sum(),\n  );\n}\n\n/**\n * @private\n * Function that pow 2 each element of a Matrix or a Vector,\n * used in the apply method of the Matrix object\n * @param {number} i - index i.\n * @param {number} j - index j.\n * @return {Matrix} The Matrix object modified at the index i, j.\n * */\nexport function pow2array(i, j) {\n  this.set(i, j, this.get(i, j) ** 2);\n}\n\n/**\n * @private\n * Function that normalize the dataset and return the means and\n * standard deviation of each feature.\n * @param {Matrix} dataset\n * @return {object} dataset normalized, means and standard deviations\n */\nexport function featureNormalize(dataset) {\n  let means = dataset.mean('column');\n  let std = dataset.standardDeviation('column', {\n    mean: means,\n    unbiased: true,\n  });\n  let result = Matrix.checkMatrix(dataset).subRowVector(means);\n  return { result: result.divRowVector(std), means: means, std: std };\n}\n\n/**\n * @private\n * Function that initialize an array of matrices.\n * @param {Array} array\n * @param {boolean} isMatrix\n * @return {Array} array with the matrices initialized.\n */\nexport function initializeMatrices(array, isMatrix) {\n  if (isMatrix) {\n    for (let i = 0; i < array.length; ++i) {\n      for (let j = 0; j < array[i].length; ++j) {\n        let elem = array[i][j];\n        array[i][j] = elem !== null ? new Matrix(array[i][j]) : undefined;\n      }\n    }\n  } else {\n    for (let i = 0; i < array.length; ++i) {\n      array[i] = new Matrix(array[i]);\n    }\n  }\n\n  return array;\n}\n\n// /**\n//  * @private\n//  * Get total sum of square\n//  * @param {Array} x an array\n//  */\n// export function tss(x) {\n//   return x\n//     .clone()\n//     .mul(x.clone())\n//     .sum();\n// }\n\n/**\n * @private\n * Compute Q2 statistics\n * @param {Array} realY an array with real/true values\n * @param {Array} predictedY an array with predicted values\n * @return {Number} Q2 statistics\n */\nexport function Q2(realY, predictedY) {\n  realY = Matrix.checkMatrix(realY);\n  predictedY = Matrix.checkMatrix(predictedY);\n  let meansY = mean(realY);\n\n  let press = predictedY.map((row, rowIndex) => {\n    return row.map((element, colIndex) => {\n      return Math.pow(realY[rowIndex][colIndex] - element, 2);\n    });\n  });\n\n  let tss = Y.map((row) => {\n    return row.map((element, colIndex) => {\n      return Math.pow(element - meansY[colIndex], 2);\n    });\n  });\n\n  press = Matrix.checkMatrix(press).sum();\n  tss = Matrix.checkMatrix(tss).sum();\n\n  return 1 - press / tss;\n}\n\n/**\n * @private\n * create a dataset from data\n * @param {Object} object with parameters\n * @return {Object} dataset object\n */\n\nexport const Dataset = ({ dataMatrix, options } = {}) => {\n  let nObs = dataMatrix.rows;\n  let nVar = dataMatrix.columns;\n\n  let aa = {};\n  const {\n    descriptio = 123,\n    // observations = Array(nObs).fill(null).map((x, i) => 'OBS' + (i + 1)),\n    // variables = Array(nVar).fill(null).map((x, i) => 'VAR' + (i + 1)),\n    // description = 'NA'\n    // metadata = [],\n    // outliers = []\n  } = aa;\n\n  let defaults = {\n    observations: Array(nObs)\n      .fill(null)\n      .map((x, i) => `OBS${i + 1}`),\n    variables: Array(nVar)\n      .fill(null)\n      .map((x, i) => `VAR${i + 1}`),\n    description: 'NA',\n    metadata: [],\n    outliers: [],\n  };\n\n  options = Object.assign({}, defaults, options);\n\n  let observations = options.observations;\n  let variables = options.variables;\n  let description = options.description;\n  let dataClass = options.dataClass;\n  let metadata = options.metadata;\n  let outliers = options.outliers;\n\n  if (\n    options.observations.length !== nObs ||\n    options.variables.length !== nVar ||\n    options.dataClass[0].value.length !== nObs\n  ) {\n    throw new RangeError(\n      'observations and dataMatrix have different number of rows',\n    );\n  }\n\n  // private util functions\n\n  function getRowIndexByID() {\n    let sampleList = observations.map((x) => x);\n    let outlierList = outliers.map((x) => x.id);\n    let ind = outlierList.map((e) => sampleList.indexOf(e));\n    return ind;\n  }\n\n  function getClassVector(dataClass) {\n    let title = dataClass.title;\n    let classVector = dataClass.value;\n    let type = typeof classVector[0];\n    let counts = {};\n    switch (type) {\n      case 'string':\n        counts = {};\n        classVector.forEach((x) => (counts[x] = (counts[x] || 0) + 1));\n        break;\n      case 'number':\n        classVector = classVector.map((x) => x.toString());\n        counts = {};\n        classVector.forEach((x) => (counts[x] = (counts[x] || 0) + 1));\n        break;\n      default:\n    }\n    let groupIDs = Object.keys(counts);\n    let nClass = groupIDs.length;\n    let classFactor = classVector.map((x) => groupIDs.indexOf(x));\n    let classMatrix = Matrix.from1DArray(nObs, 1, classFactor);\n    return { title, groupIDs, nClass, classVector, classFactor, classMatrix };\n  }\n\n  return {\n    description,\n\n    // API exposed functions\n\n    getClass() {\n      let a = dataClass.map((x) => getClassVector(x));\n      return a;\n    },\n\n    getOutliers() {\n      return outliers;\n    },\n\n    addOutliers(outliersList) {\n      let outliersIDs = outliers.map((x) => x.id);\n      let newList = outliersList.filter((f) => !outliersIDs.includes(f.id));\n      console.log(newList);\n      if (newList.length > 0) newList.forEach((e) => outliers.push(e));\n      console.log(outliers);\n      this.summary();\n      // return this;\n    },\n\n    rmOutliers(outliersList) {\n      outliers = outliers.filter((f) => !outliersList.includes(f.id));\n      console.log(outliers);\n      this.summary();\n      // return this;\n    },\n\n    clean() {\n      if (outliers.length > 0) {\n        let ind = getRowIndexByID();\n        console.log(ind);\n        let cleanObservations = observations.filter((e, i) => !ind.includes(i));\n        let cleanDataMatrix = new Matrix(nObs - ind.length, nVar);\n\n        let counter = 0;\n        dataMatrix.forEach((e, i) => {\n          if (!ind.includes(i)) {\n            cleanDataMatrix.setRow(counter, e);\n            counter += 1;\n          }\n        });\n\n        let cleanDataClass = dataClass.map((x) => {\n          return {\n            title: x.title,\n            value: x.value.filter((e, i) => !ind.includes(i)),\n          };\n        });\n        // let cleanMetadata = metadata.filter((e, i) => !ind.includes(i));\n\n        return Dataset({\n          dataMatrix: cleanDataMatrix,\n          options: {\n            observations: cleanObservations,\n            variables: variables,\n            dataClass: cleanDataClass,\n            outliers: [],\n            // metadata: cleanMetadata, // lack of test for dimensions\n            description: `clean ${description}`,\n          },\n        });\n      } else {\n        return this;\n      }\n    },\n\n    sample(list) {\n      // console.log(list.length)\n      if (list.length > 0) {\n        let ind = list;\n        // console.log(ind);\n        // filter Observations vector\n\n        let trainObservations = observations.filter((e, i) => !ind.includes(i));\n        let testObservations = observations.filter((e, i) => ind.includes(i));\n\n        // filter data matrix\n        let trainDataMatrix = new Matrix(nObs - ind.length, nVar);\n        let testDataMatrix = new Matrix(ind.length, nVar);\n\n        let counter = 0;\n        dataMatrix.forEach((e, i) => {\n          if (!ind.includes(i)) {\n            trainDataMatrix.setRow(counter, e);\n            counter += 1;\n          }\n        });\n\n        counter = 0;\n        dataMatrix.forEach((e, i) => {\n          if (ind.includes(i)) {\n            testDataMatrix.setRow(counter, e);\n            counter += 1;\n          }\n        });\n\n        // filter class vector\n        let trainDataClass = dataClass.map((x) => {\n          return {\n            title: x.title,\n            value: x.value.filter((e, i) => !ind.includes(i)),\n          };\n        });\n\n        let testDataClass = dataClass.map((x) => {\n          return {\n            title: x.title,\n            value: x.value.filter((e, i) => ind.includes(i)),\n          };\n        });\n\n        // let cleanMetadata = metadata.filter((e, i) => !ind.includes(i));\n\n        let train = Dataset({\n          dataMatrix: trainDataMatrix,\n          options: {\n            observations: trainObservations,\n            variables: variables,\n            dataClass: trainDataClass,\n            outliers: [],\n            // metadata: cleanMetadata, // lack of test for dimensions\n            description: `train ${description}`,\n          },\n        });\n\n        let test = Dataset({\n          dataMatrix: testDataMatrix,\n          options: {\n            observations: testObservations,\n            variables: variables,\n            dataClass: testDataClass,\n            outliers: [],\n            // metadata: cleanMetadata, // lack of test for dimensions\n            description: `test ${description}`,\n          },\n        });\n\n        return { train, test };\n      } else {\n        return this;\n      }\n    },\n\n    // return everything but cannot be changed\n    summary(verbose = 0) {\n      if (verbose === 1) {\n        console.log(\n          `Description: ${description}\\nNumber of variables: ${nVar}\\nNumber of observations: ${nObs}\\nNumber of outliers:${\n            outliers.length\n          }\\nHas class: ${dataClass.length}\\nHas metadata: ${metadata.length >\n            0}`,\n        );\n      }\n      return {\n        dataMatrix,\n        dataClass,\n        nObs,\n        nVar,\n        observations,\n        variables,\n        metadata,\n        description,\n      };\n    },\n  };\n};\n\n/* *\n * @private\n * Shuffles array for permutation (from ml knn.js)\n * @param {Array} array\n */\n/* export function shuffleArray(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n} */\n\n/**\n * @private\n * create a class vector\n * @param {String} title a title for the class\n * @param {*} value\n */\n/* export const DataClass = (title, value) => {\n  let dataClasses = [];\n  dataClasses.push({ title, value });\n  return ({\n    getClass() {\n      return dataClasses;\n    },\n    addClass(title, value) {\n      dataClasses.push({ title, value });\n      return this;\n    }\n  });\n}; */\n\nexport function sampleAClass(classVector, fraction) {\n  // sort the vector\n  let classVectorSorted = JSON.parse(JSON.stringify(classVector));\n  let result = Array.from(Array(classVectorSorted.length).keys()).sort((a, b) =>\n    classVectorSorted[a] < classVectorSorted[b]\n      ? -1\n      : (classVectorSorted[b] < classVectorSorted[a]) | 0,\n  );\n  classVectorSorted.sort((a, b) => (a < b ? -1 : (b < a) | 0));\n\n  // counts the class elements\n  let counts = {};\n  classVectorSorted.forEach((x) => (counts[x] = (counts[x] || 0) + 1));\n\n  // pick a few per class\n  let indexOfSelected = [];\n\n  Object.keys(counts).forEach((e, i) => {\n    let shift = [];\n    Object.values(counts).reduce((a, c, i) => (shift[i] = a + c), 0);\n\n    let arr = [...Array(counts[e]).keys()];\n\n    let r = [];\n    for (let i = 0; i < Math.floor(counts[e] * fraction); i++) {\n      let n = arr[Math.floor(Math.random() * arr.length)];\n      r.push(n);\n      let ind = arr.indexOf(n);\n      arr.splice(ind, 1);\n    }\n\n    i == 0\n      ? (indexOfSelected = indexOfSelected.concat(r))\n      : (indexOfSelected = indexOfSelected.concat(\n          r.map((x) => x + shift[i - 1]),\n        ));\n  });\n\n  // sort back the index\n  let trainIndex = [];\n  indexOfSelected.forEach((e) => trainIndex.push(result[e]));\n\n  let testIndex = [];\n  let mask = [];\n  classVector.forEach((el, idx) => {\n    if (trainIndex.includes(idx)) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n      testIndex.push(idx);\n    }\n  });\n  return { trainIndex, testIndex, mask };\n}\n\nexport function summaryMetadata(classVector) {\n  let nObs = classVector.length;\n  let type = typeof classVector[0];\n  let counts = {};\n  switch (type) {\n    case 'string':\n      counts = {};\n      classVector.forEach((x) => (counts[x] = (counts[x] || 0) + 1));\n      break;\n    case 'number':\n      classVector = classVector.map((x) => x.toString());\n      counts = {};\n      classVector.forEach((x) => (counts[x] = (counts[x] || 0) + 1));\n      break;\n    default:\n  }\n  let groupIDs = Object.keys(counts);\n  let nClass = groupIDs.length;\n  let classFactor = classVector.map((x) => groupIDs.indexOf(x));\n  let classMatrix = Matrix.from1DArray(nObs, 1, classFactor);\n  return { groupIDs, nClass, classVector, classFactor, classMatrix };\n}\n","import Matrix from 'ml-matrix';\n\nimport * as Utils from './utils';\n\n/**\n * @class PLS\n */\nexport class PLS {\n  /**\n   * Constructor for Partial Least Squares (PLS)\n   * @param {object} options\n   * @param {number} [options.latentVectors] - Number of latent vector to get (if the algorithm doesn't find a good model below the tolerance)\n   * @param {number} [options.tolerance=1e-5]\n   * @param {boolean} [options.scale=true] - rescale dataset using mean.\n   * @param {object} model - for load purposes.\n   */\n  constructor(options, model) {\n    if (options === true) {\n      this.meanX = model.meanX;\n      this.stdDevX = model.stdDevX;\n      this.meanY = model.meanY;\n      this.stdDevY = model.stdDevY;\n      this.PBQ = Matrix.checkMatrix(model.PBQ);\n      this.R2X = model.R2X;\n      this.scale = model.scale;\n      this.scaleMethod = model.scaleMethod;\n      this.tolerance = model.tolerance;\n    } else {\n      let { tolerance = 1e-5, scale = true } = options;\n      this.tolerance = tolerance;\n      this.scale = scale;\n      this.latentVectors = options.latentVectors;\n    }\n  }\n\n  /**\n   * Fits the model with the given data and predictions, in this function is calculated the\n   * following outputs:\n   *\n   * T - Score matrix of X\n   * P - Loading matrix of X\n   * U - Score matrix of Y\n   * Q - Loading matrix of Y\n   * B - Matrix of regression coefficient\n   * W - Weight matrix of X\n   *\n   * @param {Matrix|Array} trainingSet\n   * @param {Matrix|Array} trainingValues\n   */\n  train(trainingSet, trainingValues) {\n    trainingSet = Matrix.checkMatrix(trainingSet);\n    trainingValues = Matrix.checkMatrix(trainingValues);\n\n    if (trainingSet.length !== trainingValues.length) {\n      throw new RangeError(\n        'The number of X rows must be equal to the number of Y rows',\n      );\n    }\n\n    this.meanX = trainingSet.mean('column');\n    this.stdDevX = trainingSet.standardDeviation('column', {\n      mean: this.meanX,\n      unbiased: true,\n    });\n    this.meanY = trainingValues.mean('column');\n    this.stdDevY = trainingValues.standardDeviation('column', {\n      mean: this.meanY,\n      unbiased: true,\n    });\n\n    if (this.scale) {\n      trainingSet = trainingSet\n        .clone()\n        .subRowVector(this.meanX)\n        .divRowVector(this.stdDevX);\n      trainingValues = trainingValues\n        .clone()\n        .subRowVector(this.meanY)\n        .divRowVector(this.stdDevY);\n    }\n\n    if (this.latentVectors === undefined) {\n      this.latentVectors = Math.min(trainingSet.rows - 1, trainingSet.columns);\n    }\n\n    let rx = trainingSet.rows;\n    let cx = trainingSet.columns;\n    let ry = trainingValues.rows;\n    let cy = trainingValues.columns;\n\n    let ssqXcal = trainingSet\n      .clone()\n      .mul(trainingSet)\n      .sum(); // for the r²\n    let sumOfSquaresY = trainingValues\n      .clone()\n      .mul(trainingValues)\n      .sum();\n\n    let tolerance = this.tolerance;\n    let n = this.latentVectors;\n    let T = Matrix.zeros(rx, n);\n    let P = Matrix.zeros(cx, n);\n    let U = Matrix.zeros(ry, n);\n    let Q = Matrix.zeros(cy, n);\n    let B = Matrix.zeros(n, n);\n    let W = P.clone();\n    let k = 0;\n\n    while (Utils.norm(trainingValues) > tolerance && k < n) {\n      let transposeX = trainingSet.transpose();\n      let transposeY = trainingValues.transpose();\n\n      let tIndex = maxSumColIndex(trainingSet.clone().mul(trainingSet));\n      let uIndex = maxSumColIndex(trainingValues.clone().mul(trainingValues));\n\n      let t1 = trainingSet.getColumnVector(tIndex);\n      let u = trainingValues.getColumnVector(uIndex);\n      var t = Matrix.zeros(rx, 1);\n\n      while (Utils.norm(t1.clone().sub(t)) > tolerance) {\n        var w = transposeX.mmul(u);\n        w.div(Utils.norm(w));\n        t = t1;\n        t1 = trainingSet.mmul(w);\n        var q = transposeY.mmul(t1);\n        q.div(Utils.norm(q));\n        u = trainingValues.mmul(q);\n      }\n\n      t = t1;\n      let num = transposeX.mmul(t);\n      let den = t\n        .transpose()\n        .mmul(t)\n        .get(0, 0);\n      var p = num.div(den);\n      let pnorm = Utils.norm(p);\n      p.div(pnorm);\n      t.mul(pnorm);\n      w.mul(pnorm);\n\n      num = u.transpose().mmul(t);\n      den = t\n        .transpose()\n        .mmul(t)\n        .get(0, 0);\n      let b = num.div(den).get(0, 0);\n      trainingSet.sub(t.mmul(p.transpose()));\n      trainingValues.sub(\n        t\n          .clone()\n          .mul(b)\n          .mmul(q.transpose()),\n      );\n\n      T.setColumn(k, t);\n      P.setColumn(k, p);\n      U.setColumn(k, u);\n      Q.setColumn(k, q);\n      W.setColumn(k, w);\n\n      B.set(k, k, b);\n      k++;\n    }\n\n    k--;\n    T = T.subMatrix(0, T.rows - 1, 0, k);\n    P = P.subMatrix(0, P.rows - 1, 0, k);\n    U = U.subMatrix(0, U.rows - 1, 0, k);\n    Q = Q.subMatrix(0, Q.rows - 1, 0, k);\n    W = W.subMatrix(0, W.rows - 1, 0, k);\n    B = B.subMatrix(0, k, 0, k);\n\n    // TODO: review of R2Y\n    // this.R2Y = t.transpose().mmul(t).mul(q[k][0]*q[k][0]).divS(ssqYcal)[0][0];\n    //\n    this.ssqYcal = sumOfSquaresY;\n    this.E = trainingSet;\n    this.F = trainingValues;\n    this.T = T;\n    this.P = P;\n    this.U = U;\n    this.Q = Q;\n    this.W = W;\n    this.B = B;\n    this.PBQ = P.mmul(B).mmul(Q.transpose());\n    this.R2X = t\n      .transpose()\n      .mmul(t)\n      .mmul(p.transpose().mmul(p))\n      .div(ssqXcal)\n      .get(0, 0);\n  }\n\n  /**\n   * Predicts the behavior of the given dataset.\n   * @param {Matrix|Array} dataset - data to be predicted.\n   * @return {Matrix} - predictions of each element of the dataset.\n   */\n  predict(dataset) {\n    let X = Matrix.checkMatrix(dataset);\n    if (this.scale) {\n      X = X.subRowVector(this.meanX).divRowVector(this.stdDevX);\n    }\n    let Y = X.mmul(this.PBQ);\n    Y = Y.mulRowVector(this.stdDevY).addRowVector(this.meanY);\n    return Y;\n  }\n\n  /**\n   * Returns the explained variance on training of the PLS model\n   * @return {number}\n   */\n  getExplainedVariance() {\n    return this.R2X;\n  }\n\n  /**\n   * Export the current model to JSON.\n   * @return {object} - Current model.\n   */\n  toJSON() {\n    return {\n      name: 'PLS',\n      R2X: this.R2X,\n      meanX: this.meanX,\n      stdDevX: this.stdDevX,\n      meanY: this.meanY,\n      stdDevY: this.stdDevY,\n      PBQ: this.PBQ,\n      tolerance: this.tolerance,\n      scale: this.scale,\n    };\n  }\n\n  /**\n   * Load a PLS model from a JSON Object\n   * @param {object} model\n   * @return {PLS} - PLS object from the given model\n   */\n  static load(model) {\n    if (model.name !== 'PLS') {\n      throw new RangeError(`Invalid model: ${model.name}`);\n    }\n    return new PLS(true, model);\n  }\n}\n\n/**\n * @private\n * Function that returns the index where the sum of each\n * column vector is maximum.\n * @param {Matrix} data\n * @return {number} index of the maximum\n */\nfunction maxSumColIndex(data) {\n  return Matrix.rowVector(data.sum('column')).maxIndex()[0];\n}\n","import { Matrix, SingularValueDecomposition, inverse } from 'ml-matrix';\n\nimport { initializeMatrices } from './utils';\n\n/**\n * @class KOPLS\n */\nexport class KOPLS {\n  /**\n   * Constructor for Kernel-based Orthogonal Projections to Latent Structures (K-OPLS)\n   * @param {object} options\n   * @param {number} [options.predictiveComponents] - Number of predictive components to use.\n   * @param {number} [options.orthogonalComponents] - Number of Y-Orthogonal components.\n   * @param {Kernel} [options.kernel] - Kernel object to apply, see [ml-kernel](https://github.com/mljs/kernel).\n   * @param {object} model - for load purposes.\n   */\n  constructor(options, model) {\n    if (options === true) {\n      this.trainingSet = new Matrix(model.trainingSet);\n      this.YLoadingMat = new Matrix(model.YLoadingMat);\n      this.SigmaPow = new Matrix(model.SigmaPow);\n      this.YScoreMat = new Matrix(model.YScoreMat);\n      this.predScoreMat = initializeMatrices(model.predScoreMat, false);\n      this.YOrthLoadingVec = initializeMatrices(model.YOrthLoadingVec, false);\n      this.YOrthEigen = model.YOrthEigen;\n      this.YOrthScoreMat = initializeMatrices(model.YOrthScoreMat, false);\n      this.toNorm = initializeMatrices(model.toNorm, false);\n      this.TURegressionCoeff = initializeMatrices(\n        model.TURegressionCoeff,\n        false,\n      );\n      this.kernelX = initializeMatrices(model.kernelX, true);\n      this.kernel = model.kernel;\n      this.orthogonalComp = model.orthogonalComp;\n      this.predictiveComp = model.predictiveComp;\n    } else {\n      if (options.predictiveComponents === undefined) {\n        throw new RangeError('no predictive components found!');\n      }\n      if (options.orthogonalComponents === undefined) {\n        throw new RangeError('no orthogonal components found!');\n      }\n      if (options.kernel === undefined) {\n        throw new RangeError('no kernel found!');\n      }\n\n      this.orthogonalComp = options.orthogonalComponents;\n      this.predictiveComp = options.predictiveComponents;\n      this.kernel = options.kernel;\n    }\n  }\n\n  /**\n   * Train the K-OPLS model with the given training set and labels.\n   * @param {Matrix|Array} trainingSet\n   * @param {Matrix|Array} trainingValues\n   */\n  train(trainingSet, trainingValues) {\n    trainingSet = Matrix.checkMatrix(trainingSet);\n    trainingValues = Matrix.checkMatrix(trainingValues);\n\n    // to save and compute kernel with the prediction dataset.\n    this.trainingSet = trainingSet.clone();\n\n    let kernelX = this.kernel.compute(trainingSet);\n\n    let Identity = Matrix.eye(kernelX.rows, kernelX.rows, 1);\n    let temp = kernelX;\n    kernelX = new Array(this.orthogonalComp + 1);\n    for (let i = 0; i < this.orthogonalComp + 1; i++) {\n      kernelX[i] = new Array(this.orthogonalComp + 1);\n    }\n    kernelX[0][0] = temp;\n\n    let result = new SingularValueDecomposition(\n      trainingValues\n        .transpose()\n        .mmul(kernelX[0][0])\n        .mmul(trainingValues),\n      {\n        computeLeftSingularVectors: true,\n        computeRightSingularVectors: false,\n      },\n    );\n    let YLoadingMat = result.leftSingularVectors;\n    let Sigma = result.diagonalMatrix;\n\n    YLoadingMat = YLoadingMat.subMatrix(\n      0,\n      YLoadingMat.rows - 1,\n      0,\n      this.predictiveComp - 1,\n    );\n    Sigma = Sigma.subMatrix(\n      0,\n      this.predictiveComp - 1,\n      0,\n      this.predictiveComp - 1,\n    );\n\n    let YScoreMat = trainingValues.mmul(YLoadingMat);\n\n    let predScoreMat = new Array(this.orthogonalComp + 1);\n    let TURegressionCoeff = new Array(this.orthogonalComp + 1);\n    let YOrthScoreMat = new Array(this.orthogonalComp);\n    let YOrthLoadingVec = new Array(this.orthogonalComp);\n    let YOrthEigen = new Array(this.orthogonalComp);\n    let YOrthScoreNorm = new Array(this.orthogonalComp);\n\n    let SigmaPow = Matrix.pow(Sigma, -0.5);\n    // to avoid errors, check infinity\n    SigmaPow.apply(function(i, j) {\n      if (this.get(i, j) === Infinity) {\n        this.set(i, j, 0);\n      }\n    });\n\n    for (let i = 0; i < this.orthogonalComp; ++i) {\n      predScoreMat[i] = kernelX[0][i]\n        .transpose()\n        .mmul(YScoreMat)\n        .mmul(SigmaPow);\n\n      let TpiPrime = predScoreMat[i].transpose();\n      TURegressionCoeff[i] = inverse(TpiPrime.mmul(predScoreMat[i]))\n        .mmul(TpiPrime)\n        .mmul(YScoreMat);\n\n      result = new SingularValueDecomposition(\n        TpiPrime.mmul(\n          Matrix.sub(kernelX[i][i], predScoreMat[i].mmul(TpiPrime)),\n        ).mmul(predScoreMat[i]),\n        {\n          computeLeftSingularVectors: true,\n          computeRightSingularVectors: false,\n        },\n      );\n      let CoTemp = result.leftSingularVectors;\n      let SoTemp = result.diagonalMatrix;\n\n      YOrthLoadingVec[i] = CoTemp.subMatrix(0, CoTemp.rows - 1, 0, 0);\n      YOrthEigen[i] = SoTemp.get(0, 0);\n\n      YOrthScoreMat[i] = Matrix.sub(\n        kernelX[i][i],\n        predScoreMat[i].mmul(TpiPrime),\n      )\n        .mmul(predScoreMat[i])\n        .mmul(YOrthLoadingVec[i])\n        .mul(Math.pow(YOrthEigen[i], -0.5));\n\n      let toiPrime = YOrthScoreMat[i].transpose();\n      YOrthScoreNorm[i] = Matrix.sqrt(toiPrime.mmul(YOrthScoreMat[i]));\n\n      YOrthScoreMat[i] = YOrthScoreMat[i].divRowVector(YOrthScoreNorm[i]);\n\n      let ITo = Matrix.sub(\n        Identity,\n        YOrthScoreMat[i].mmul(YOrthScoreMat[i].transpose()),\n      );\n\n      kernelX[0][i + 1] = kernelX[0][i].mmul(ITo);\n      kernelX[i + 1][i + 1] = ITo.mmul(kernelX[i][i]).mmul(ITo);\n    }\n\n    let lastScoreMat = (predScoreMat[this.orthogonalComp] = kernelX[0][\n      this.orthogonalComp\n    ]\n      .transpose()\n      .mmul(YScoreMat)\n      .mmul(SigmaPow));\n\n    let lastTpPrime = lastScoreMat.transpose();\n    TURegressionCoeff[this.orthogonalComp] = inverse(\n      lastTpPrime.mmul(lastScoreMat),\n    )\n      .mmul(lastTpPrime)\n      .mmul(YScoreMat);\n\n    this.YLoadingMat = YLoadingMat;\n    this.SigmaPow = SigmaPow;\n    this.YScoreMat = YScoreMat;\n    this.predScoreMat = predScoreMat;\n    this.YOrthLoadingVec = YOrthLoadingVec;\n    this.YOrthEigen = YOrthEigen;\n    this.YOrthScoreMat = YOrthScoreMat;\n    this.toNorm = YOrthScoreNorm;\n    this.TURegressionCoeff = TURegressionCoeff;\n    this.kernelX = kernelX;\n  }\n\n  /**\n   * Predicts the output given the matrix to predict.\n   * @param {Matrix|Array} toPredict\n   * @return {{y: Matrix, predScoreMat: Array<Matrix>, predYOrthVectors: Array<Matrix>}} predictions\n   */\n  predict(toPredict) {\n    let KTestTrain = this.kernel.compute(toPredict, this.trainingSet);\n\n    let temp = KTestTrain;\n    KTestTrain = new Array(this.orthogonalComp + 1);\n    for (let i = 0; i < this.orthogonalComp + 1; i++) {\n      KTestTrain[i] = new Array(this.orthogonalComp + 1);\n    }\n    KTestTrain[0][0] = temp;\n\n    let YOrthScoreVector = new Array(this.orthogonalComp);\n    let predScoreMat = new Array(this.orthogonalComp);\n\n    let i;\n    for (i = 0; i < this.orthogonalComp; ++i) {\n      predScoreMat[i] = KTestTrain[i][0]\n        .mmul(this.YScoreMat)\n        .mmul(this.SigmaPow);\n\n      YOrthScoreVector[i] = Matrix.sub(\n        KTestTrain[i][i],\n        predScoreMat[i].mmul(this.predScoreMat[i].transpose()),\n      )\n        .mmul(this.predScoreMat[i])\n        .mmul(this.YOrthLoadingVec[i])\n        .mul(Math.pow(this.YOrthEigen[i], -0.5));\n\n      YOrthScoreVector[i] = YOrthScoreVector[i].divRowVector(this.toNorm[i]);\n\n      let scoreMatPrime = this.YOrthScoreMat[i].transpose();\n      KTestTrain[i + 1][0] = Matrix.sub(\n        KTestTrain[i][0],\n        YOrthScoreVector[i]\n          .mmul(scoreMatPrime)\n          .mmul(this.kernelX[0][i].transpose()),\n      );\n\n      let p1 = Matrix.sub(\n        KTestTrain[i][0],\n        KTestTrain[i][i].mmul(this.YOrthScoreMat[i]).mmul(scoreMatPrime),\n      );\n      let p2 = YOrthScoreVector[i].mmul(scoreMatPrime).mmul(this.kernelX[i][i]);\n      let p3 = p2.mmul(this.YOrthScoreMat[i]).mmul(scoreMatPrime);\n\n      KTestTrain[i + 1][i + 1] = p1.sub(p2).add(p3);\n    }\n\n    predScoreMat[i] = KTestTrain[i][0].mmul(this.YScoreMat).mmul(this.SigmaPow);\n    let prediction = predScoreMat[i]\n      .mmul(this.TURegressionCoeff[i])\n      .mmul(this.YLoadingMat.transpose());\n\n    return {\n      prediction: prediction,\n      predScoreMat: predScoreMat,\n      predYOrthVectors: YOrthScoreVector,\n    };\n  }\n\n  /**\n   * Export the current model to JSON.\n   * @return {object} - Current model.\n   */\n  toJSON() {\n    return {\n      name: 'K-OPLS',\n      YLoadingMat: this.YLoadingMat,\n      SigmaPow: this.SigmaPow,\n      YScoreMat: this.YScoreMat,\n      predScoreMat: this.predScoreMat,\n      YOrthLoadingVec: this.YOrthLoadingVec,\n      YOrthEigen: this.YOrthEigen,\n      YOrthScoreMat: this.YOrthScoreMat,\n      toNorm: this.toNorm,\n      TURegressionCoeff: this.TURegressionCoeff,\n      kernelX: this.kernelX,\n      trainingSet: this.trainingSet,\n      orthogonalComp: this.orthogonalComp,\n      predictiveComp: this.predictiveComp,\n    };\n  }\n\n  /**\n   * Load a K-OPLS with the given model.\n   * @param {object} model\n   * @param {Kernel} kernel - kernel used on the model, see [ml-kernel](https://github.com/mljs/kernel).\n   * @return {KOPLS}\n   */\n  static load(model, kernel) {\n    if (model.name !== 'K-OPLS') {\n      throw new RangeError(`Invalid model: ${model.name}`);\n    }\n\n    if (!kernel) {\n      throw new RangeError('You must provide a kernel for the model!');\n    }\n\n    model.kernel = kernel;\n    return new KOPLS(true, model);\n  }\n}\n","/**\n *  Constructs a confusion matrix\n * @class ConfusionMatrix\n * @example\n * const CM = new ConfusionMatrix([[13, 2], [10, 5]], ['cat', 'dog'])\n * @param {Array<Array<number>>} matrix - The confusion matrix, a 2D Array. Rows represent the actual label and columns\n *     the predicted label.\n * @param {Array<any>} labels - Labels of the confusion matrix, a 1D Array\n */\nexport default class ConfusionMatrix {\n  constructor(matrix, labels) {\n    if (matrix.length !== matrix[0].length) {\n      throw new Error('Confusion matrix must be square');\n    }\n    if (labels.length !== matrix.length) {\n      throw new Error(\n        'Confusion matrix and labels should have the same length',\n      );\n    }\n    this.labels = labels;\n    this.matrix = matrix;\n  }\n\n  /**\n   * Construct confusion matrix from the predicted and actual labels (classes). Be sure to provide the arguments in\n   * the correct order!\n   * @param {Array<any>} actual  - The predicted labels of the classification\n   * @param {Array<any>} predicted     - The actual labels of the classification. Has to be of same length as\n   *     predicted.\n   * @param {object} [options] - Additional options\n   * @param {Array<any>} [options.labels] - The list of labels that should be used. If not provided the distinct set\n   *     of labels present in predicted and actual is used. Labels are compared using the strict equality operator\n   *     '==='\n   * @return {ConfusionMatrix} - Confusion matrix\n   */\n  static fromLabels(actual, predicted, options = {}) {\n    if (predicted.length !== actual.length) {\n      throw new Error('predicted and actual must have the same length');\n    }\n    let distinctLabels;\n    if (options.labels) {\n      distinctLabels = new Set(options.labels);\n    } else {\n      distinctLabels = new Set([...actual, ...predicted]);\n    }\n    distinctLabels = Array.from(distinctLabels);\n    if (options.sort) {\n      distinctLabels.sort(options.sort);\n    }\n\n    // Create confusion matrix and fill with 0's\n    const matrix = Array.from({ length: distinctLabels.length });\n    for (let i = 0; i < matrix.length; i++) {\n      matrix[i] = new Array(matrix.length);\n      matrix[i].fill(0);\n    }\n\n    for (let i = 0; i < predicted.length; i++) {\n      const actualIdx = distinctLabels.indexOf(actual[i]);\n      const predictedIdx = distinctLabels.indexOf(predicted[i]);\n      if (actualIdx >= 0 && predictedIdx >= 0) {\n        matrix[actualIdx][predictedIdx]++;\n      }\n    }\n\n    return new ConfusionMatrix(matrix, distinctLabels);\n  }\n\n  /**\n   * Get the confusion matrix\n   * @return {Array<Array<number> >}\n   */\n  getMatrix() {\n    return this.matrix;\n  }\n\n  getLabels() {\n    return this.labels;\n  }\n\n  /**\n   * Get the total number of samples\n   * @return {number}\n   */\n  getTotalCount() {\n    let predicted = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      for (let j = 0; j < this.matrix.length; j++) {\n        predicted += this.matrix[i][j];\n      }\n    }\n    return predicted;\n  }\n\n  /**\n   * Get the total number of true predictions\n   * @return {number}\n   */\n  getTrueCount() {\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      count += this.matrix[i][i];\n    }\n    return count;\n  }\n\n  /**\n   * Get the total number of false predictions.\n   * @return {number}\n   */\n  getFalseCount() {\n    return this.getTotalCount() - this.getTrueCount();\n  }\n\n  /**\n   * Get the number of true positive predictions.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getTruePositiveCount(label) {\n    const index = this.getIndex(label);\n    return this.matrix[index][index];\n  }\n\n  /**\n   * Get the number of true negative predictions\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getTrueNegativeCount(label) {\n    const index = this.getIndex(label);\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      for (let j = 0; j < this.matrix.length; j++) {\n        if (i !== index && j !== index) {\n          count += this.matrix[i][j];\n        }\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the number of false positive predictions.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalsePositiveCount(label) {\n    const index = this.getIndex(label);\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      if (i !== index) {\n        count += this.matrix[i][index];\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the number of false negative predictions.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseNegativeCount(label) {\n    const index = this.getIndex(label);\n    let count = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      if (i !== index) {\n        count += this.matrix[index][i];\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the number of real positive samples.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getPositiveCount(label) {\n    return this.getTruePositiveCount(label) + this.getFalseNegativeCount(label);\n  }\n\n  /**\n   * Get the number of real negative samples.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getNegativeCount(label) {\n    return this.getTrueNegativeCount(label) + this.getFalsePositiveCount(label);\n  }\n\n  /**\n   * Get the index in the confusion matrix that corresponds to the given label\n   * @param {any} label - The label to search for\n   * @throws if the label is not found\n   * @return {number}\n   */\n  getIndex(label) {\n    const index = this.labels.indexOf(label);\n    if (index === -1) throw new Error('The label does not exist');\n    return index;\n  }\n\n  /**\n   * Get the true positive rate a.k.a. sensitivity. Computes the ratio between the number of true positive predictions and the total number of positive samples.\n   * {@link https://en.wikipedia.org/wiki/Sensitivity_and_specificity}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number} - The true positive rate [0-1]\n   */\n  getTruePositiveRate(label) {\n    return this.getTruePositiveCount(label) / this.getPositiveCount(label);\n  }\n\n  /**\n   * Get the true negative rate a.k.a. specificity. Computes the ration between the number of true negative predictions and the total number of negative samples.\n   * {@link https://en.wikipedia.org/wiki/Sensitivity_and_specificity}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getTrueNegativeRate(label) {\n    return this.getTrueNegativeCount(label) / this.getNegativeCount(label);\n  }\n\n  /**\n   * Get the positive predictive value a.k.a. precision. Computes TP / (TP + FP)\n   * {@link https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getPositivePredictiveValue(label) {\n    const TP = this.getTruePositiveCount(label);\n    return TP / (TP + this.getFalsePositiveCount(label));\n  }\n\n  /**\n   * Negative predictive value\n   * {@link https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getNegativePredictiveValue(label) {\n    const TN = this.getTrueNegativeCount(label);\n    return TN / (TN + this.getFalseNegativeCount(label));\n  }\n\n  /**\n   * False negative rate a.k.a. miss rate.\n   * {@link https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseNegativeRate(label) {\n    return 1 - this.getTruePositiveRate(label);\n  }\n\n  /**\n   * False positive rate a.k.a. fall-out rate.\n   * {@link https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalsePositiveRate(label) {\n    return 1 - this.getTrueNegativeRate(label);\n  }\n\n  /**\n   * False discovery rate (FDR)\n   * {@link https://en.wikipedia.org/wiki/False_discovery_rate}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseDiscoveryRate(label) {\n    const FP = this.getFalsePositiveCount(label);\n    return FP / (FP + this.getTruePositiveCount(label));\n  }\n\n  /**\n   * False omission rate (FOR)\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getFalseOmissionRate(label) {\n    const FN = this.getFalseNegativeCount(label);\n    return FN / (FN + this.getTruePositiveCount(label));\n  }\n\n  /**\n   * F1 score\n   * {@link https://en.wikipedia.org/wiki/F1_score}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getF1Score(label) {\n    const TP = this.getTruePositiveCount(label);\n    return (\n      (2 * TP) /\n      (2 * TP +\n        this.getFalsePositiveCount(label) +\n        this.getFalseNegativeCount(label))\n    );\n  }\n\n  /**\n   * Matthews correlation coefficient (MCC)\n   * {@link https://en.wikipedia.org/wiki/Matthews_correlation_coefficient}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getMatthewsCorrelationCoefficient(label) {\n    const TP = this.getTruePositiveCount(label);\n    const TN = this.getTrueNegativeCount(label);\n    const FP = this.getFalsePositiveCount(label);\n    const FN = this.getFalseNegativeCount(label);\n    return (\n      (TP * TN - FP * FN) /\n      Math.sqrt((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN))\n    );\n  }\n\n  /**\n   * Informedness\n   * {@link https://en.wikipedia.org/wiki/Youden%27s_J_statistic}\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getInformedness(label) {\n    return (\n      this.getTruePositiveRate(label) + this.getTrueNegativeRate(label) - 1\n    );\n  }\n\n  /**\n   * Markedness\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {number}\n   */\n  getMarkedness(label) {\n    return (\n      this.getPositivePredictiveValue(label) +\n      this.getNegativePredictiveValue(label) -\n      1\n    );\n  }\n\n  /**\n   * Get the confusion table.\n   * @param {any} label - The label that should be considered \"positive\"\n   * @return {Array<Array<number> >} - The 2x2 confusion table. [[TP, FN], [FP, TN]]\n   */\n  getConfusionTable(label) {\n    return [\n      [this.getTruePositiveCount(label), this.getFalseNegativeCount(label)],\n      [this.getFalsePositiveCount(label), this.getTrueNegativeCount(label)],\n    ];\n  }\n\n  /**\n   * Get total accuracy.\n   * @return {number} - The ratio between the number of true predictions and total number of classifications ([0-1])\n   */\n  getAccuracy() {\n    let correct = 0;\n    let incorrect = 0;\n    for (let i = 0; i < this.matrix.length; i++) {\n      for (let j = 0; j < this.matrix.length; j++) {\n        if (i === j) correct += this.matrix[i][j];\n        else incorrect += this.matrix[i][j];\n      }\n    }\n    return correct / (correct + incorrect);\n  }\n\n  /**\n   * Returns the element in the confusion matrix that corresponds to the given actual and predicted labels.\n   * @param {any} actual - The true label\n   * @param {any} predicted - The predicted label\n   * @return {number} - The element in the confusion matrix\n   */\n  getCount(actual, predicted) {\n    const actualIndex = this.getIndex(actual);\n    const predictedIndex = this.getIndex(predicted);\n    return this.matrix[actualIndex][predictedIndex];\n  }\n\n  /**\n   * Compute the general prediction accuracy\n   * @deprecated Use getAccuracy\n   * @return {number} - The prediction accuracy ([0-1]\n   */\n  get accuracy() {\n    return this.getAccuracy();\n  }\n\n  /**\n   * Compute the number of predicted observations\n   * @deprecated Use getTotalCount\n   * @return {number}\n   */\n  get total() {\n    return this.getTotalCount();\n  }\n}\n","import Matrix from 'ml-matrix';\n\nimport { norm, pow2array } from './utils.js';\n\nlet Utils = {};\nUtils.norm = function norm(X) {\n  return Math.sqrt(\n    X.clone()\n      .apply(pow2array)\n      .sum(),\n  );\n};\n\n/**\n * OPLS loop\n * @param {Array} x a matrix with features\n * @param {Array} y an array of labels (dependent variable)\n * @param {Object} options an object with options\n * @return {Object} an object with model (filteredX: err,\n    loadingsXOrtho: pOrtho,\n    scoresXOrtho: tOrtho,\n    weightsXOrtho: wOrtho,\n    weightsPred: w,\n    loadingsXpred: p,\n    scoresXpred: t,\n    loadingsY:)\n */\nexport function oplsNIPALS(x, y, options = {}) {\n  const { numberOSC = 100 } = options;\n\n  let X = Matrix.checkMatrix(x.clone());\n  let Y = Matrix.checkMatrix(y.clone());\n\n  let u = Y.getColumnVector(0);\n\n  let diff = 1;\n  let t, c, w, uNew;\n  for (let i = 0; i < numberOSC && diff > 1e-10; i++) {\n    w = u\n      .transpose()\n      .mmul(X)\n      .div(\n        u\n          .transpose()\n          .mmul(u)\n          .get(0, 0),\n      );\n    w = w.transpose().div(norm(w));\n\n    t = X.mmul(w).div(\n      w\n        .transpose()\n        .mmul(w)\n        .get(0, 0),\n    ); // t_h paso 3\n\n    // calc loading\n    c = t\n      .transpose()\n      .mmul(Y)\n      .div(\n        t\n          .transpose()\n          .mmul(t)\n          .get(0, 0),\n      );\n\n    // calc new u and compare with one in previus iteration (stop criterion)\n    uNew = Y.mmul(c.transpose());\n    uNew = uNew.div(\n      c\n        .transpose()\n        .mmul(c)\n        .get(0, 0),\n    );\n\n    if (i > 0) {\n      diff =\n        uNew\n          .clone()\n          .sub(u)\n          .pow(2)\n          .sum() /\n        uNew\n          .clone()\n          .pow(2)\n          .sum();\n    }\n\n    u = uNew.clone();\n  }\n\n  // calc loadings\n  let p = t\n    .transpose()\n    .mmul(X)\n    .div(\n      t\n        .transpose()\n        .mmul(t)\n        .get(0, 0),\n    );\n\n  let wOrtho = p.clone().sub(\n    w\n      .transpose()\n      .mmul(p.transpose())\n      .div(\n        w\n          .transpose()\n          .mmul(w)\n          .get(0, 0),\n      )\n      .mmul(w.transpose()),\n  );\n  wOrtho.div(Utils.norm(wOrtho));\n\n  // orthogonal scores\n  let tOrtho = X.mmul(wOrtho.transpose()).div(\n    wOrtho.mmul(wOrtho.transpose()).get(0, 0),\n  );\n\n  // orthogonal loadings\n  let pOrtho = tOrtho\n    .transpose()\n    .mmul(X)\n    .div(\n      tOrtho\n        .transpose()\n        .mmul(tOrtho)\n        .get(0, 0),\n    );\n\n  // filtered data\n  let err = X.clone().sub(tOrtho.mmul(pOrtho));\n  return {\n    filteredX: err,\n    weightsXOrtho: wOrtho,\n    loadingsXOrtho: pOrtho,\n    scoresXOrtho: tOrtho,\n    weightsXPred: w,\n    loadingsXpred: p,\n    scoresXpred: t,\n    loadingsY: c,\n  };\n}\n","/**\n * Get total sum of square\n * @param {Array} x an array\n * @return {Number} - the sum of the squares\n */\nexport function tss(x) {\n  return x\n    .clone()\n    .mul(x.clone())\n    .sum();\n}\n","import { Matrix, NIPALS } from 'ml-matrix';\nimport ConfusionMatrix from 'ml-confusion-matrix';\nimport { getFolds } from 'ml-cross-validation';\n\n// import { getTrainTest } from 'ml-cross-validation';\n\nimport { oplsNIPALS } from './oplsNIPALS.js';\n// import { getFolds } from './getFolds.js';\nimport { tss } from './tss.js';\n\n/**\n * Creates new OPLS (orthogonal partial latent structures) from features and labels.\n * @param {Matrix} data - matrix containing data (X).\n * @param {Array} labels - 1D Array containing metadata (Y).\n * @param {Object} [options]\n * @param {number} [options.nComp = 3] - number of latent structures computed.\n * @param {boolean} [options.center = true] - should the data be centered (subtract the mean).\n * @param {boolean} [options.scale = false] - should the data be scaled (divide by the standard deviation).\n * @param {Array} [options.cvFolds = []] - allows to provide folds as 2D array for testing purpose.\n * */\n\nexport class OPLS {\n  constructor(data, labels, options = {}) {\n    if (data === true) {\n      const opls = options;\n      this.center = opls.center;\n      this.scale = opls.scale;\n      this.means = opls.means;\n      this.stdevs = opls.stdevs;\n      this.model = opls.model;\n      this.tCV = opls.tCV;\n      this.tOrthCV = opls.tOrthCV;\n      this.mode = opls.mode;\n      return;\n    }\n\n    let features = data.clone();\n    // set default values\n    // cvFolds allows to define folds for testing purpose\n    const { nComp = 3, center = true, scale = true, cvFolds = [] } = options;\n\n    let group;\n    if (typeof labels[0] === 'number') {\n      // numeric labels: OPLS regression is used\n      this.mode = 'regression';\n      group = Matrix.from1DArray(labels.length, 1, labels);\n    } else if (typeof labels[0] === 'string') {\n      // non-numeric labels: OPLS-DA is used\n      this.mode = 'discriminant_analysis';\n      group = labels;\n      throw new Error('discriminant analysis is not yet supported');\n    }\n\n    // check types of features and labels\n    if (features.constructor.name !== 'Matrix') {\n      throw new TypeError('features must be of class Matrix');\n    }\n    // getting center and scale the features (all)\n    this.center = center;\n    if (this.center) {\n      this.means = features.mean('column');\n      // console.log('training mean: ', this.means);\n    } else {\n      this.stdevs = null;\n    }\n    this.scale = scale;\n    if (this.scale) {\n      this.stdevs = features.standardDeviation('column');\n      // console.log('training sdevs: ', this.stdevs);\n    } else {\n      this.means = null;\n    }\n\n    // check and remove for features with sd = 0 TODO here\n    // check opls.R line 70\n\n    let folds;\n    if (cvFolds.length > 0) {\n      folds = cvFolds;\n    } else {\n      folds = getFolds(labels, 5);\n    }\n\n    let Q2 = [];\n    this.model = [];\n\n    this.tCV = [];\n    this.tOrthCV = [];\n    let yHatCV = [];\n    let oplsCV = [];\n\n    let modelNC = [];\n\n    // this code could be made more efficient by reverting the order of the loops\n    // this is a legacy loop to be consistent with R code from MetaboMate package\n    // this allows for having statistic (R2) from CV to decide wether to continue\n    // with more latent structures\n    let nc;\n    for (nc = 0; nc < nComp; nc++) {\n      let yHatk = new Matrix(group.rows, 1);\n      let tPredk = new Matrix(group.rows, 1);\n      let tOrthk = new Matrix(group.rows, 1);\n      let oplsk = [];\n\n      let f = 0;\n      for (let fold of folds) {\n        let trainTest = this._getTrainTest(features, group, fold);\n        let testXk = trainTest.testFeatures;\n        let Xk = trainTest.trainFeatures;\n        let Yk = trainTest.trainLabels;\n\n        // determine center and scale of training set\n        let dataCenter = Xk.mean('column');\n        let dataSD = Xk.standardDeviation('column');\n\n        // center and scale training set\n        if (center) {\n          Xk.center('column');\n          Yk.center('column');\n        }\n\n        if (scale) {\n          Xk.scale('column');\n          Yk.scale('column');\n        }\n\n        // perform opls\n        if (nc === 0) {\n          oplsk[f] = oplsNIPALS(Xk, Yk);\n        } else {\n          oplsk[f] = oplsNIPALS(oplsCV[nc - 1][f].filteredX, Yk);\n        }\n        // store model for next component\n        oplsCV[nc] = oplsk;\n\n        let plsCV = new NIPALS(oplsk[f].filteredX, { Y: Yk });\n\n        // scaling the test dataset with respect to the train\n        testXk.center('column', { center: dataCenter });\n        testXk.scale('column', { scale: dataSD });\n\n        let Eh = testXk;\n        // removing the orthogonal components from PLS\n        let scores;\n        for (let idx = 0; idx < nc + 1; idx++) {\n          scores = Eh.clone().mmul(oplsCV[idx][f].weightsXOrtho.transpose()); // ok\n          Eh.sub(scores.clone().mmul(oplsCV[idx][f].loadingsXOrtho));\n        }\n\n        // prediction\n        let tPred = Eh.clone().mmul(plsCV.w.transpose());\n        // this should be summed over ncomp (pls_prediction.R line 23)\n        let yHat = tPred.clone().mmul(plsCV.betas); // ok\n\n        // adding all prediction from all folds\n        for (let i = 0; i < fold.testIndex.length; i++) {\n          yHatk.setRow(fold.testIndex[i], [yHat.get(i, 0)]);\n          tPredk.setRow(fold.testIndex[i], [tPred.get(i, 0)]);\n          tOrthk.setRow(fold.testIndex[i], [scores.get(i, 0)]);\n        }\n        f++;\n      } // end of loop over folds\n\n      this.tCV.push(tPredk);\n      this.tOrthCV.push(tOrthk);\n      yHatCV.push(yHatk);\n\n      // calculate Q2y for all the prediction (all folds)\n      // ROC for DA is not implemented (check opls.R line 183) TODO\n      if (this.mode === 'regression') {\n        let tssy = tss(group.center('column').scale('column'));\n        let press = tss(group.clone().sub(yHatk));\n        let Q2y = 1 - press / tssy;\n        Q2.push(Q2y);\n      } else if (this.mode === 'discriminant_analysis') {\n        throw new Error('discriminant analysis is not yet supported');\n      }\n\n      // calculate the R2y for the complete data\n      if (nc === 0) {\n        modelNC = this._predictAll(features, group);\n      } else {\n        modelNC = this._predictAll(\n          modelNC.xRes,\n          group,\n          (options = { scale: false, center: false }),\n        );\n      }\n\n      // adding the predictive statistics from CV\n      modelNC.Q2y = Q2;\n      // store the model for each component\n      this.model.push(modelNC);\n      // console.warn(`OPLS iteration over # of Components: ${nc + 1}`);\n    } // end of loop over nc\n\n    // store scores from CV\n    let tCV = this.tCV;\n    let tOrthCV = this.tOrthCV;\n\n    let m = this.model[nc - 1];\n    let XOrth = m.XOrth;\n    let FeaturesCS = features.center('column').scale('column');\n    let labelsCS = group.center('column').scale('column');\n    let Xres = FeaturesCS.clone().sub(XOrth);\n    let plsCall = new NIPALS(Xres, { Y: labelsCS });\n    let E = Xres.clone().sub(plsCall.t.clone().mmul(plsCall.p));\n\n    let R2x = this.model.map((x) => x.R2x);\n    let R2y = this.model.map((x) => x.R2y);\n\n    this.output = {\n      Q2y: Q2,\n      R2x,\n      R2y,\n      tPred: m.plsC.t,\n      pPred: m.plsC.p,\n      wPred: m.plsC.w,\n      betasPred: m.plsC.betas,\n      Qpc: m.plsC.q,\n      tCV,\n      tOrthCV,\n      tOrth: m.tOrth,\n      pOrth: m.pOrth,\n      wOrth: m.wOrth,\n      XOrth,\n      Yres: m.plsC.yResidual,\n      E,\n    };\n  }\n\n  /**\n   * get access to all the computed elements\n   * Mainly for debug and testing\n   * @return {Object} output object\n   */\n  getLogs() {\n    return this.output;\n  }\n\n  getScores() {\n    let scoresX = this.tCV.map((x) => x.to1DArray());\n    let scoresY = this.tOrthCV.map((x) => x.to1DArray());\n    return { scoresX, scoresY };\n  }\n\n  /**\n   * Load an OPLS model from JSON\n   * @param {Object} model\n   * @return {OPLS}\n   */\n  static load(model) {\n    if (typeof model.name !== 'string') {\n      throw new TypeError('model must have a name property');\n    }\n    if (model.name !== 'OPLS') {\n      throw new RangeError(`invalid model: ${model.name}`);\n    }\n    return new OPLS(true, [], model);\n  }\n\n  /**\n   * Export the current model to a JSON object\n   * @return {Object} model\n   */\n  toJSON() {\n    return {\n      name: 'OPLS',\n      center: this.center,\n      scale: this.scale,\n      means: this.means,\n      stdevs: this.stdevs,\n      model: this.model,\n      tCV: this.tCV,\n      tOrthCV: this.tOrthCV,\n    };\n  }\n\n  /**\n   * Predict scores for new data\n   * @param {Matrix} features - a matrix containing new data\n   * @param {Object} [options]\n   * @param {Array} [options.trueLabel] - an array with true values to compute confusion matrix\n   * @param {Number} [options.nc] - the number of components to be used\n   * @return {Object} - predictions\n   */\n  predict(newData, options = {}) {\n    let { trueLabels = [], nc = 1 } = options;\n    let labels = [];\n    if (trueLabels.length > 0) {\n      trueLabels = Matrix.from1DArray(trueLabels.length, 1, trueLabels);\n      labels = trueLabels.clone();\n    }\n\n    let features = newData.clone();\n\n    // scaling the test dataset with respect to the train\n    if (this.center) {\n      features.center('column');\n      // features.clone().center('column', { center: this.means });\n      // if (labels.rows > 0) {\n      labels.center('column');\n      // }\n    }\n    if (this.scale) {\n      features.scale('column');\n      // features.clone().scale('column', { scale: this.stdevs });\n      // if (labels.rows > 0) {\n      labels.scale('column');\n      // }\n    }\n\n    let Eh = features.clone();\n    // removing the orthogonal components from PLS\n    let tOrth;\n    let wOrth;\n    let pOrth;\n    let yHat;\n    let tPred;\n\n    for (let idx = 0; idx < nc; idx++) {\n      wOrth = this.model[idx].wOrth.transpose();\n      pOrth = this.model[idx].pOrth;\n      tOrth = Eh.clone().mmul(wOrth);\n      Eh.sub(tOrth.clone().mmul(pOrth));\n      // prediction\n      tPred = Eh.clone().mmul(this.model[idx].plsC.w.transpose());\n      // this should be summed over ncomp (pls_prediction.R line 23)\n      yHat = tPred.clone().mmul(this.model[idx].plsC.betas);\n    }\n    // console.log(yHat);\n    // console.log(labels);\n\n    if (labels.rows > 0) {\n      if (this.mode === 'regression') {\n        let tssy = tss(labels);\n        let press = tss(labels.clone().sub(yHat));\n        let Q2y = 1 - press / tssy;\n\n        return { tPred, tOrth, yHat, Q2y };\n      } else if (this.mode === 'discriminant_analysis') {\n        let confusionMatrix = [];\n        confusionMatrix = ConfusionMatrix.fromLabels(\n          trueLabels.to1DArray(),\n          yHat.to1DArray(),\n        );\n\n        return { tPred, tOrth, yHat, confusionMatrix };\n      }\n    } else {\n      return { tPred, tOrth, yHat };\n    }\n  }\n\n  _predictAll(features, labels, options = {}) {\n    // cannot use the global this.center here\n    // since it is used in the NC loop and\n    // centering and scaling should only be\n    // performed once\n    const { center = true, scale = true } = options;\n\n    if (center) {\n      features.center('column');\n      labels.center('column');\n    }\n\n    if (scale) {\n      features.scale('column');\n      labels.scale('column');\n      // reevaluate tssy and tssx after scaling\n      // must be global because re-used for next nc iteration\n      // tssx is only evaluate the first time\n      this.tssy = tss(labels);\n      this.tssx = tss(features);\n    }\n\n    let oplsC = oplsNIPALS(features, labels);\n    let plsC = new NIPALS(oplsC.filteredX, { Y: labels });\n\n    let tPred = oplsC.filteredX.clone().mmul(plsC.w.transpose());\n    let yHat = tPred.clone().mmul(plsC.betas);\n\n    let rss = tss(labels.clone().sub(yHat));\n    let R2y = 1 - rss / this.tssy;\n\n    let xEx = plsC.t.clone().mmul(plsC.p.clone());\n    let rssx = tss(xEx);\n    let R2x = rssx / this.tssx;\n\n    return {\n      R2y,\n      R2x,\n      xRes: oplsC.filteredX,\n      tOrth: oplsC.scoresXOrtho,\n      pOrth: oplsC.loadingsXOrtho,\n      wOrth: oplsC.weightsXOrtho,\n      tPred: tPred,\n      totalPred: yHat,\n      XOrth: oplsC.scoresXOrtho.clone().mmul(oplsC.loadingsXOrtho),\n      oplsC,\n      plsC,\n    };\n  }\n  /**\n   *\n   * @param {*} X - dataset matrix object\n   * @param {*} group - labels matrix object\n   * @param {*} index - train and test index (output from getFold())\n   */\n  _getTrainTest(X, group, index) {\n    let testFeatures = new Matrix(index.testIndex.length, X.columns);\n    let testLabels = new Matrix(index.testIndex.length, 1);\n    index.testIndex.forEach((el, idx) => {\n      testFeatures.setRow(idx, X.getRow(el));\n      testLabels.setRow(idx, group.getRow(el));\n    });\n\n    let trainFeatures = new Matrix(index.trainIndex.length, X.columns);\n    let trainLabels = new Matrix(index.trainIndex.length, 1);\n    index.trainIndex.forEach((el, idx) => {\n      trainFeatures.setRow(idx, X.getRow(el));\n      trainLabels.setRow(idx, group.getRow(el));\n    });\n\n    return {\n      trainFeatures,\n      testFeatures,\n      trainLabels,\n      testLabels,\n    };\n  }\n}\n","/**\n * get folds indexes\n * @param {Array} features\n * @param {Number} k - number of folds, a\n */\nexport function getFolds(features, k = 5) {\n  let N = features.length;\n  let allIdx = new Array(N);\n  for (let i = 0; i < N; i++) {\n    allIdx[i] = i;\n  }\n\n  let l = Math.floor(N / k);\n  // create random k-folds\n  let current = [];\n  let folds = [];\n  while (allIdx.length) {\n    let randi = Math.floor(Math.random() * allIdx.length);\n    current.push(allIdx[randi]);\n    allIdx.splice(randi, 1);\n    if (current.length === l) {\n      folds.push(current);\n      current = [];\n    }\n  }\n  // we push the remaining to the last fold so that the total length is\n  // preserved. Otherwise the Q2 will fail.\n  if (current.length) current.forEach((e) => folds[k - 1].push(e));\n  folds = folds.slice(0, k);\n\n  let foldsIndex = folds.map((x, idx) => ({\n    testIndex: x,\n    trainIndex: [].concat(...folds.filter((el, idx2) => idx2 !== idx)),\n  }));\n  return foldsIndex;\n}\n"],"names":["toString","Object","prototype","object","call","endsWith","max","input","isArray","TypeError","length","maxValue","i","min","minValue","rescale","output","options","arguments","undefined","Array","currentMin","currentMax","RangeError","_options$min","autoMinMax","_options$max","factor","checkRowIndex","matrix","index","outer","rows","checkColumnIndex","columns","checkRowVector","vector","to1DArray","checkColumnVector","checkRowIndices","rowIndices","some","r","from","checkColumnIndices","columnIndices","c","checkRange","startRow","endRow","startColumn","endColumn","checkNumber","newArray","value","array","push","name","formatNumber","num","numStr","String","padEnd","precise","toPrecision","maxNumSize","exponential","toExponential","eIndex","indexOf","e","substring","AbstractMatrix","newRows","newColumns","newData","newMatrix","Matrix","row","column","set","fill","random","Math","j","Number","isInteger","interval","round","this","zeros","data","l","matrix1","matrix2","checkMatrix","result","get","isMatrix","klass","apply","callback","to2DArray","copy","toJSON","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","isEchelonForm","previousColumn","checked","isReducedEchelonForm","k","echelonForm","clone","h","iMax","swapRows","tmp","reducedEchelonForm","m","n","maxRow","p","pivot","Error","repeat","setSubMatrix","neg","mulS","getRow","getRowVector","rowVector","setRow","row1","row2","temp","getColumn","getColumnVector","columnVector","setColumn","swapColumns","column1","column2","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","v","maxIndex","idx","minIndex","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","diag","norm","type","sqrt","cumulativeSum","sum","dot","vector2","vector1","mmul","other","Bcolj","Float64Array","s","strassen2x2","a11","b11","a12","b12","a21","b21","a22","b22","m1","m2","m3","m4","m5","c00","c01","c10","c11","strassen3x3","a00","a01","a02","a10","a20","b00","b01","b02","b10","b20","m6","m7","m8","m9","m12","m13","m14","m15","m16","m17","m18","c02","c12","c20","c21","c22","mmulStrassen","y","x","r1","c1","r2","c2","embed","mat","cols","resultat","console","warn","blockMult","a","b","halfRows","parseInt","halfCols","subMatrix","add","sub","scaleRows","isFinite","scaleColumns","flipRows","middle","ceil","first","last","flipColumns","kroneckerProduct","q","transpose","sortRows","compareFunction","compareNumbers","sort","sortColumns","subMatrixRow","indices","subMatrixColumn","selection","checkIndices","rowIndex","columnIndex","trace","by","sumByRow","sumByColumn","sumAll","product","productByRow","productByColumn","productAll","mean","size","variance","unbiased","sum1","sum2","varianceByRow","varianceByColumn","varianceAll","standardDeviation","center","centerByRow","centerByColumn","centerAll","scale","pow","getScaleByRow","scaleByRow","getScaleByColumn","scaleByColumn","divider","getScaleAll","scaleAll","Symbol","for","indent","indentData","constructor","maxI","maxJ","line","join","inspectData","rand","randomInt","randInt","diagonal","identity","eye","negate","tensorProduct","nRows","nColumns","arrayData","removeRow","splice","addRow","removeColumn","newRow","addColumn","addS","addM","subS","subM","subtract","subtractS","subtractM","mul","mulM","multiply","multiplyS","multiplyM","div","divS","divM","divide","divideS","divideM","mod","modS","modM","modulus","modulusS","modulusM","and","andS","andM","or","orS","orM","xor","xorS","xorM","leftShift","leftShiftS","leftShiftM","signPropagatingRightShift","signPropagatingRightShiftS","signPropagatingRightShiftM","rightShift","rightShiftS","rightShiftM","zeroFillRightShift","zeroFillRightShiftS","zeroFillRightShiftM","not","abs","acos","acosh","asin","asinh","atan","atanh","cbrt","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","sign","sin","sinh","tan","tanh","trunc","arg0","powS","powM","installMathOperations","WrapperMatrix2D","LuDecomposition","t","LUcolj","kmax","lu","pivotVector","pivotSign","LU","isSingular","col","solve","count","X","determinant","hypotenuse","QrDecomposition","qr","rdiag","nrm","QR","Rdiag","isFullRank","SingularValueDecomposition","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","wantu","Boolean","wantv","swapped","aux","nu","ni","U","V","work","si","nct","nrt","mrc","pp","eps","EPSILON","kase","alpha","MIN_VALUE","isNaN","ks","f","cs","sn","sp","spm1","epm1","sk","ek","shift","g","Y","threshold","scols","Ls","rightSingularVectors","VL","vrows","urows","VLU","solveForDiagonal","inverse","vcols","ucols","tol","ii","useSVD","leftHandSide","rightHandSide","nipals","scaleScores","maxIterations","terminationCriteria","u","w","tOld","diff","counter","xResidual","residual","yResidual","betas","pow2array","initializeMatrices","elem","PLS","model","meanX","stdDevX","meanY","stdDevY","PBQ","R2X","scaleMethod","tolerance","latentVectors","train","trainingSet","trainingValues","rx","cx","ry","cy","ssqXcal","sumOfSquaresY","T","P","Q","B","W","Utils","transposeX","transposeY","tIndex","maxSumColIndex","uIndex","t1","den","pnorm","ssqYcal","E","F","predict","dataset","getExplainedVariance","KOPLS","YLoadingMat","SigmaPow","YScoreMat","predScoreMat","YOrthLoadingVec","YOrthEigen","YOrthScoreMat","toNorm","TURegressionCoeff","kernelX","kernel","orthogonalComp","predictiveComp","predictiveComponents","orthogonalComponents","compute","Identity","leftSingularVectors","Sigma","diagonalMatrix","YOrthScoreNorm","Infinity","TpiPrime","CoTemp","SoTemp","toiPrime","ITo","lastScoreMat","lastTpPrime","toPredict","KTestTrain","YOrthScoreVector","scoreMatPrime","p1","p2","p3","prediction","predYOrthVectors","ConfusionMatrix","labels","actual","predicted","distinctLabels","Set","actualIdx","predictedIdx","getMatrix","getLabels","getTotalCount","getTrueCount","getFalseCount","getTruePositiveCount","label","getIndex","getTrueNegativeCount","getFalsePositiveCount","getFalseNegativeCount","getPositiveCount","getNegativeCount","getTruePositiveRate","getTrueNegativeRate","getPositivePredictiveValue","TP","getNegativePredictiveValue","TN","getFalseNegativeRate","getFalsePositiveRate","getFalseDiscoveryRate","FP","getFalseOmissionRate","FN","getF1Score","getMatthewsCorrelationCoefficient","getInformedness","getMarkedness","getConfusionTable","getAccuracy","correct","incorrect","getCount","actualIndex","predictedIndex","oplsNIPALS","numberOSC","uNew","wOrtho","tOrtho","pOrtho","err","filteredX","weightsXOrtho","loadingsXOrtho","scoresXOrtho","weightsXPred","loadingsXpred","scoresXpred","loadingsY","tss","OPLS","opls","means","stdevs","tCV","tOrthCV","mode","features","nComp","cvFolds","group","folds","from1DArray","N","allIdx","current","randi","forEach","slice","foldsIndex","map","testIndex","trainIndex","concat","filter","el","idx2","getFolds","Q2","nc","oplsCV","modelNC","yHatk","tPredk","tOrthk","oplsk","fold","trainTest","_getTrainTest","testXk","testFeatures","Xk","trainFeatures","Yk","trainLabels","dataCenter","dataSD","plsCV","NIPALS","scores","Eh","tPred","yHat","tssy","Q2y","_predictAll","xRes","XOrth","FeaturesCS","labelsCS","Xres","plsCall","R2x","R2y","plsC","pPred","wPred","betasPred","Qpc","tOrth","pOrth","wOrth","Yres","getLogs","getScores","scoresX","scoresY","trueLabels","confusionMatrix","fromLabels","tssx","oplsC","totalPred","testLabels","classVector","nObs","counts","groupIDs","keys","nClass","classFactor","classMatrix"],"mappings":"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"}